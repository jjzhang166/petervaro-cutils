<html><!-- www.cutils.org | Peter Varo | 2014 --><head><link href="http://www.cutils.org/favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="http://www.cutils.org/favicon.ico" rel="icon" type="image/x-icon"/><title>CCOM Comment Scanner</title><meta charset="utf-8"/><link href="css/cdoc.css" rel="stylesheet" type="text/css"/></head><body><div id="column1"><div id="generic"><img src="img/cutils.svg"/><br/><h2><span>MODERN AND LIGHTWEIGHT C UTILITIES</span></h2><p><span>&mdash;</span></p><p><span>DESIGNED BY</span></p><p><span>PETER VARO &copy;2014</span></p><p><span>&mdash;</span></p><br/></div><div id="sidebar"><div><p class="label">Modules:</p></div><br/><a class="toc" href="index.html">CUTILS</a><a class="toc" href="c11.html">C11 Syntax Highlighter</a><a class="toc" href="cref.html">CREF Quick Reference</a><a class="toc" href="cenv.html">CENV Environment Generator</a><a class="toc" href="cdep.html">CDEP Dependeny Graph</a><a class="toc toc_current" href="#">CCOM Comment Scanner</a><a class="toc" href="cver.html">CVER Versioning</a><a class="toc" href="clic.html">CLIC License Comment Generator</a><a class="toc" href="cres.html">CRES External Resources Packer</a><a class="toc" href="capi.html">CAPI Interface</a><a class="toc" href="carg.html">CARG Variadic Argument Macro</a><a class="toc" href="cbug.html">CBUG Debugging &amp; Logging</a><a class="toc" href="cexc.html">CEXC Exception Handling</a><a class="toc" href="cpro.html">CPRO Profiling</a><a class="toc" href="cutt.html">CUTT Unit Testing Tools</a><a class="toc" href="cdar.html">CDAR Dynamic Array</a><a class="toc" href="cstr.html">CSTR Strings</a><a class="toc" href="csll.html">CSLL Single Linked List</a><a class="toc" href="cdll.html">CDLL Double Linked List</a><a class="toc" href="cmap.html">CMAP HashMap</a><a class="toc" href="cfps.html">CFPS Frame Per Second</a><a class="toc" href="ccol.html">CCOL Color Helper</a><a class="toc" href="cdoc.html">CDOC Documenting Tool</a><a class="toc" href="call.html">CALL Include All</a><br/><div><p class="label">Dependencies:</p><br/><a class="toc" href="#user_Python_3">Python 3</a><a class="toc" href="#user_pyhashxx">pyhashxx</a></div><br/><div><p class="label">Usage:</p><br/><a class="toc" href="#user_Command_Line_Tool">Command Line Tool</a></div><br/><div><p class="label">Functions:</p><br/><a class="toc" href="#func_ccom_collect">ccom.collect()</a></div></div></div><div id="column2"><div id="content"><h1><span>CCOM | Comment Scanner</span></h1><br/><p><span>This small utility let you scan all your source files very quickly
and search for specific comments, collect them and organise them
into a readable, but also yaml-ready file.
</span></p><br/><div><h2 class="title">Dependencies</h2><div class="entity" id="user_Python_3"><p class="name">Python 3</p><br/><p class="info"><span>This module is written in </span><code>Python 3</code><span>, therefore it needs the interpreter
to be installed on your system to run it. I suggest you to use a
package-manager to keep your installations ordered, clean and upto-date.
</span></p><br/></div><p class="info label"></p><p class="info note"><span></span><b><span>Macintosh:</span></b><span> one can use </span><a class="inline_link" href="http://brew.sh/"><span>homebrew</span></a><span>:</span></p><br/><pre class="info"><code class="snippet">brew install python3</code></pre><br/><p class="info note"><span></span><b><span>Windows:</span></b><span> one can use </span><a class="inline_link" href="https://chocolatey.org/"><span>chocolatey</span></a><span>:</span></p><br/><pre class="info"><code class="snippet">cinst python3</code></pre><br/><p class="info note"><span></span><b><span>Linux:</span></b><span> on Ubuntu and LinuxMint it is already installed:</span></p><br/><pre class="info"><code class="snippet">sudo apt-get install python3</code></pre><br/><div class="entity" id="user_pyhashxx"><p class="name">pyhashxx</p><br/><p class="info"><span>It is an optional but highly recommended dependency. Under the hood
</span><code>ccom</code><span> is hashing the files, to detect if a file has been changed or
not. Because </span><code>pyhashxx</code><span> is the fastest hashing algorithm, it will speed up
the checking process. By default the fallback mechanism is </span><code>SHA1</code><span> hashing
which is way slower.
</span></p><br/></div><p class="info label"></p><p class="info note"><span></span><code>pyhashxx</code><span> is available to install through </span><code>pip</code><span>:</span></p><br/><pre class="info"><code class="snippet">pip3 install pyhashxx</code></pre><br/></div><div><h2 class="title">Usage</h2><div class="entity" id="user_Command_Line_Tool"><p class="name">Command Line Tool</p><br/><p class="info"><span>Scans </span><code>C</code><span> header and implementation files, </span><code>Python</code><span> source files, </span><code>OpenGL</code><span> shader files and </span><code>YAML</code><span> files, searching for comments start with </span><code>fixme:</code><span>, </span><code>todo:</code><span>, </span><code>bug:</code><span>, </span><code>hack:</code><span>, </span><code>note:</code><span>, </span><code>xxx:</code><span>, </span><code>!!!</code><span> and </span><code>???</code><span> (ignoring letter-cases for these keywords) and generates a well organised and nicely formatted list and writes it into a </span><code>YAML</code><span> compatible file anme </span><code>TODO</code><span>. </span><br/><span></span><br/><span> </span><code>ccom</code><span> can also be used as </span><code>Python</code><span> module to customise the keywords, the symbols of line and block comments or the extension of the files to scan. This makes </span><code>ccom</code><span> really powerful -- it can be used for any kind of language. This can be achieved with the </span><a class="inline_link" href="#func_ccom_collect"><span></span><code>ccom.collect</code><span></span></a><span> function. </span><br/><span></span><br/><span> </span><code>ccom</code><span> will measure the distance from the line-start to the first non-keyword line's first character and uses that distance as the absolute left value: all indentations of the other lines will be compared to this column index. </span><br/><span></span><br/><span> If a line has lower column index, it will be increased to get the same value as the first line has, otherwise the indentation will be reserved as it is. </span><br/><span></span><br/><span> Line-comments are treated as a block until a non commented line comes next.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Use it as a command line utility, passing the current folder to it.
</span><b><span>Note:</span></b><span> the </span><code>TODO</code><span> file will be generated to this folder too
:</span></p><br/><pre class="info"><code class="snippet">$ python3 ccom.py .</code></pre><br/><p class="info note"><span>Here is an example, of a line and a block comments collected:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
</span><span class="code_macros">    #define</span><span> WIZARD </span><span class="code_strings">"Albus Percival Wulfric Brian Dumbledore"</span><span>
    </span><span class="code_keywords">struct</span><span>
    {
        </span><span class="code_comments">/* note: length of the char
                 array stored in string */</span><span>
        </span><span class="code_types">size_t</span><span> length;
        
        </span><span class="code_comments">// fixme: We need to use the String</span><span>
        </span><span class="code_comments">//        "object" of cutils here</span><span>
        </span><span class="code_comments">//        instead of this simple struct</span><span>
        </span><span class="code_keywords">const</span><span> </span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>string;
    
    } Wizard </span><span class="code_operators">=</span><span> {</span><span class="code_operators">.</span><span>length </span><span class="code_operators">=</span><span> </span><span class="code_keywords">sizeof</span><span> WIZARD,
                </span><span class="code_operators">.</span><span>string  </span><span class="code_operators">=</span><span> WIZARD};
    
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span></span><code>ccom</code><span> will produce the follwoing </span><code>TODO</code><span> file from this:</span></p><br/><pre class="info"><code class="snippet">#----------------------------- 1 POSTS IN 1 FILES -----------------------------#
FIXME:
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
  # 1
  - file: main.c
    line: 10
    note: |
          We need to use the String
          "object" of cutils here
          instead of this simple struct

#----------------------------- 1 POSTS IN 1 FILES -----------------------------#
NOTE:
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
  # 1
  - file: main.c
    line: 6
    note: |
          length of the char
          array stored in string</code></pre><br/></div><div><h2 class="title">Functions</h2><div class="entity" id="func_ccom_collect"><p><span class="name">ccom.collect</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">str</span><span class="space_arg_type_name"> </span><span class="arg_name">path</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">iterable of strs</span><span class="space_arg_type_name"> </span><span class="arg_name">line</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">dict</span><span class="space_arg_type_name"> </span><span class="arg_name">block</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">iterable of strs</span><span class="space_arg_type_name"> </span><span class="arg_name">words</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">dict</span><span class="space_arg_type_name"> </span><span class="arg_name">marks</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">iterable of strs</span><span class="space_arg_type_name"> </span><span class="arg_name">extensions</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>ccom</code><span> can also be used as a module, to customise which comment
symbols, "magic" words and marks to capture or to set the extensions
of file types it will scan.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Examples:</p><p class="info note"><span>Use </span><code>ccom.collect</code><span> to capture comments start with </span><code>'note'</code><span>, </span><code>'bug'</code><span>, </span><code>'fixme'</code><span> and </span><code>'***'</code><span> special words and marks written in AppleScript, Python and HTML languages
:</span></p><br/><pre class="info"><code class="snippet">from ccom import collect

collect(path  = '.',
        line  = ('--', '#'),
        block = {'(*': '*)', '&lt;!--': '--&gt;'},
        words = ('note', 'bug', 'fixme'),
        marks = {'***': 'section'},
        extensions = ('.scpt', '.py', '.html'))</code></pre><br/><p class="info note"><span>So the this call will capture these:</span></p><br/><pre class="info"><code class="snippet">-- note: one liner in AppleScript
--       and this second line too!

# *** one liner section indicator in python ***

&lt;!-- bug: an HTML
          multiliner --&gt;

(* fixme: multiliner description
          in this AppleScript *)</code></pre><br/></div></div></div></div></body></html>