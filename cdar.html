<html><!-- www.cutils.org | Peter Varo | 2014 --><head><link href="http://www.cutils.org/favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="http://www.cutils.org/favicon.ico" rel="icon" type="image/x-icon"/><title>CDAR Dynamic Array</title><meta charset="utf-8"/><link href="css/cdoc.css" rel="stylesheet" type="text/css"/></head><body><div id="column1"><div id="generic"><img src="img/cutils.svg"/><br/><h2><span>MODERN AND LIGHTWEIGHT C UTILITIES</span></h2><p><span>&mdash;</span></p><p><span>DESIGNED BY</span></p><p><span>PETER VARO &copy;2014</span></p><p><span>&mdash;</span></p><br/></div><div id="sidebar"><div><p class="label">Modules:</p></div><br/><a class="toc" href="index.html">CUTILS</a><a class="toc" href="c11.html">C11 Syntax Highlighter</a><a class="toc" href="cref.html">CREF Quick Reference</a><a class="toc" href="cenv.html">CENV Environment Generator</a><a class="toc" href="cdep.html">CDEP Dependeny Graph</a><a class="toc" href="ccom.html">CCOM Comment Scanner</a><a class="toc" href="cver.html">CVER Versioning</a><a class="toc" href="clic.html">CLIC License Comment Generator</a><a class="toc" href="cres.html">CRES External Resources Packer</a><a class="toc" href="capi.html">CAPI Interface</a><a class="toc" href="carg.html">CARG Variadic Argument Macro</a><a class="toc" href="cbug.html">CBUG Debugging &amp; Logging</a><a class="toc" href="cexc.html">CEXC Exception Handling</a><a class="toc" href="cpro.html">CPRO Profiling</a><a class="toc" href="cutt.html">CUTT Unit Testing Tools</a><a class="toc toc_current" href="#">CDAR Dynamic Array</a><a class="toc" href="cstr.html">CSTR Strings</a><a class="toc" href="csll.html">CSLL Singly Linked List</a><a class="toc" href="cdll.html">CDLL Doubly Linked List</a><a class="toc" href="cmap.html">CMAP HashMap</a><a class="toc" href="cfps.html">CFPS Frame Per Second</a><a class="toc" href="ccol.html">CCOL Color Helper</a><a class="toc" href="cdoc.html">CDOC Documenting Tool</a><a class="toc" href="call.html">CALL Include All</a><br/><div><p class="label">Options:</p><br/><a class="toc" href="#user_Name_Mangling">Name Mangling</a></div><br/><div><p class="label">Dependencies:</p><br/><a class="toc" href="#user_cexc_h">cexc.h</a><a class="toc" href="#user_fmtc_h">fmtc.h</a><a class="toc" href="#user_fcmp_h">fcmp.h</a></div><br/><div><p class="label">Compiler Flags:</p><br/><a class="toc" href="#user_CDAR_JEM">CDAR_JEM</a><a class="toc" href="#user_CDAR_OPT">CDAR_OPT</a></div><br/><div><p class="label">Types:</p><br/><a class="toc" href="#type_DynamicArray_char">DynamicArray_char</a><a class="toc" href="#type_DynamicArray_signed_char">DynamicArray_signed_char</a><a class="toc" href="#type_DynamicArray_unsigned_char">DynamicArray_unsigned_char</a><a class="toc" href="#type_DynamicArray_char_ptr">DynamicArray_char_ptr</a><a class="toc" href="#type_DynamicArray_short">DynamicArray_short</a><a class="toc" href="#type_DynamicArray_unsigned_short">DynamicArray_unsigned_short</a><a class="toc" href="#type_DynamicArray_int">DynamicArray_int</a><a class="toc" href="#type_DynamicArray_unsigned_int">DynamicArray_unsigned_int</a><a class="toc" href="#type_DynamicArray_long">DynamicArray_long</a><a class="toc" href="#type_DynamicArray_unsigned_long">DynamicArray_unsigned_long</a><a class="toc" href="#type_DynamicArray_long_long">DynamicArray_long_long</a><a class="toc" href="#type_DynamicArray_unsigned_long_long">DynamicArray_unsigned_long_long</a><a class="toc" href="#type_DynamicArray_float">DynamicArray_float</a><a class="toc" href="#type_DynamicArray_double">DynamicArray_double</a><a class="toc" href="#type_DynamicArray_long_double">DynamicArray_long_double</a><a class="toc" href="#type_DynamicArray_bool">DynamicArray_bool</a><a class="toc" href="#type_DynamicArray_size_t">DynamicArray_size_t</a><a class="toc" href="#type_DynamicArray_ptrdiff_t">DynamicArray_ptrdiff_t</a><a class="toc" href="#type_DynamicArray_void_ptr">DynamicArray_void_ptr</a><a class="toc" href="#type_DynamicArray_String">DynamicArray_String</a></div><br/><div><p class="label">Functions:</p><br/><a class="toc" href="#func_new">new()</a><a class="toc" href="#func_del">del()</a><a class="toc" href="#func_print">print()</a><a class="toc" href="#func_data">data()</a><a class="toc" href="#func_raw">raw()</a><a class="toc" href="#func_len">len()</a><a class="toc" href="#func_size">size()</a><a class="toc" href="#func_clear">clear()</a><a class="toc" href="#func_resize">resize()</a><a class="toc" href="#func_swap">swap()</a><a class="toc" href="#func_reverse">reverse()</a><a class="toc" href="#func_append">append()</a><a class="toc" href="#func_push">push()</a><a class="toc" href="#func_pull">pull()</a><a class="toc" href="#func_pop">pop()</a><a class="toc" href="#func_sub">sub()</a><a class="toc" href="#func_truncate">truncate()</a><a class="toc" href="#func_set">set()</a><a class="toc" href="#func_get">get()</a><a class="toc" href="#func_map">map()</a><a class="toc" href="#func_find">find()</a><a class="toc" href="#func_findall">findall()</a></div></div></div><div id="column2"><div id="content"><h1><span>CDAR | Dynamic Array</span></h1><br/><p><span>Implementation of a dynamically allocated, and auto-sized array
object and its methods.
</span></p><br/><div><h2 class="title">Options</h2><div class="entity" id="user_Name_Mangling"><p class="name">Name Mangling</p><br/><p class="info"><span>However </span><code>cutils</code><span> uses very short and expressive function names which
are not confronting with any of the standard library's entities,
sometimes one wants to use some of these function, macro or type
names in one's own project for other purposes. To solve this problem
</span><code>cutils</code><span> provides a macro variable, a flag, to turn on or off the
prefixes of the variable names. By default it is turned off.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Each public function or function-like macro, or type name will have the same </span><code>cutils_</code><span> prefix, as follows
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_functions">append</span><span>();  </span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">&gt;</span><span>  </span><span class="code_functions">cutils_append</span><span>();
</span></code></pre><br/><p class="info note"><span>One can compile all files or just some of it, defining the variable through the </span><code>-D</code><span> flag of the compiler, like this
:</span></p><br/><pre class="info"><code class="snippet">cc -std=c11 -Wall -DCUTILS_NAMESPACE -c -o filename.o</code></pre><br/><p class="info note"><span>Or one can define this variable before the inclusion of the API header file
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cdar</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#define</span><span> CUTILS_NAMESPACE
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>capi</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span></code></pre><br/></div><div><h2 class="title">Dependencies</h2><div class="entity" id="user_cexc_h"><p class="name">cexc.h</p><br/><p class="info"><span></span><code>cdar</code><span>'s methods can raise exceptions, if flag + h file provided
</span></p><br/></div><div class="entity" id="user_fmtc_h"><p class="name">fmtc.h</p><br/><p class="info"><span>the internal character formatter header</span></p><br/></div><div class="entity" id="user_fcmp_h"><p class="name">fcmp.h</p><br/><p class="info"><span>the internal floating point numbers compare functions</span></p><br/></div></div><div><h2 class="title">Compiler Flags</h2><div class="entity" id="user_CDAR_JEM"><p class="name">CDAR_JEM</p><br/><p class="info"><span>Allocation functions using </span><a class="inline_link" href="http://www.canonware.com/jemalloc/"><span>jemalloc</span></a><span> (dependency)
</span></p><br/></div><div class="entity" id="user_CDAR_OPT"><p class="name">CDAR_OPT</p><br/><p class="info"><span>Most optimised: no bounds checking and no exceptions</span></p><br/></div></div><div><h2 class="title">Types</h2><div class="entity" id="type_DynamicArray_char"><span class="name">DynamicArray_char</span><span class="arg_paren"> &lt; </span><span class="arg_type">char</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_signed_char"><span class="name">DynamicArray_signed_char</span><span class="arg_paren"> &lt; </span><span class="arg_type">signed char</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_unsigned_char"><span class="name">DynamicArray_unsigned_char</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned char</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_char_ptr"><span class="name">DynamicArray_char_ptr</span><span class="arg_paren"> &lt; </span><span class="arg_type">char *</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_short"><span class="name">DynamicArray_short</span><span class="arg_paren"> &lt; </span><span class="arg_type">short</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_unsigned_short"><span class="name">DynamicArray_unsigned_short</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned short</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_int"><span class="name">DynamicArray_int</span><span class="arg_paren"> &lt; </span><span class="arg_type">int</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_unsigned_int"><span class="name">DynamicArray_unsigned_int</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned int</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_long"><span class="name">DynamicArray_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">long</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_unsigned_long"><span class="name">DynamicArray_unsigned_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned long</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_long_long"><span class="name">DynamicArray_long_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">long long</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_unsigned_long_long"><span class="name">DynamicArray_unsigned_long_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned long long</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_float"><span class="name">DynamicArray_float</span><span class="arg_paren"> &lt; </span><span class="arg_type">float</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_double"><span class="name">DynamicArray_double</span><span class="arg_paren"> &lt; </span><span class="arg_type">double</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_long_double"><span class="name">DynamicArray_long_double</span><span class="arg_paren"> &lt; </span><span class="arg_type">long double</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_bool"><span class="name">DynamicArray_bool</span><span class="arg_paren"> &lt; </span><span class="arg_type">bool</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_size_t"><span class="name">DynamicArray_size_t</span><span class="arg_paren"> &lt; </span><span class="arg_type">size_t</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_ptrdiff_t"><span class="name">DynamicArray_ptrdiff_t</span><span class="arg_paren"> &lt; </span><span class="arg_type">ptrdiff_t</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_DynamicArray_void_ptr"><span class="name">DynamicArray_void_ptr</span><span class="arg_paren"> &lt; </span><span class="arg_type">void *</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>This is the so-called universal array type, and also the base type of
all the specific typed </span><code>DynamicArray</code><span>s. It holds </span><code>void *</code><span> type of
items, therefore it can hold any kind of pointer to type. It has a
slightly different </span><a class="inline_link" href="#func_new"><span>new</span></a><span> function as well.
</span><br/><span></span><br/><span>
</span><code>DyanmicArray</code><span> stores the items by their values (copies them), not
only a pointer to them. For example if the array is a
</span><a class="inline_link" href="#type_DynamicArray_int"><span></span><code>DynamicArray_int</code><span></span></a><span> it will save a copy of
the integers themselves inside itself. Also, if for example the array
is a </span><a class="inline_link" href="#type_DynamicArray_void_ptr"><span></span><code>DynamicArray_void_ptr</code><span></span></a><span> all the
pointers will be copied and stored and pointing at the exact same
memory location as the original pointers.
</span></p><br/></div><div class="entity" id="type_DynamicArray_String"><span class="name">DynamicArray_String</span><span class="arg_paren"> &lt; </span><span class="arg_type">String</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><a class="inline_link" href="cstr.html"><span></span><code>String</code><span></span></a><span> type of items.
</span></p><br/></div></div><div><h2 class="title">Functions</h2><div class="entity" id="func_new"><p><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type **</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type **</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_void_ptr **</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_size</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_void_ptr **</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_size</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>new</code><span> is a type-generic function-like macro, which takes a pointer to
pointer to a type-specific DynamicArray to create a new array. All
types of DynamicArray can be initialised as an empty array by passing
only the pointer to pointer to the DynamicArray to the </span><code>new</code><span> method;
except the </span><code>DynamicArray_void_ptr</code><span> which also requires the size of the
type of the data it is storing.
</span><br/><span></span><br/><span>
Also: all types of DynamicArray can be initialised by arbitrary
number of data, by passing the number of items, and the pointer to the
data to the </span><code>new</code><span> method; except the </span><code>DynamicArray_void_ptr</code><span> which
also needs the size of the type of the data it is storing.
</span><br/><span></span><br/><span>
</span><b><i><span>Note:</span></i></b><span> An empty </span><code>DynamicArray</code><span> with a preallocated space in memory can be created by passing the number of items and a pointer to </span><code>NULL</code><span> to the </span><code>new</code><span> function. </span><i><span>Example:</span></i><span> </span><code>new(&amp;dynarr, 40, NULL);</code><span>
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if array was created successfully</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if internal allocation failed</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">internal allocation failed</code><p class="exception_note"><span>The allocation of space in memory for the instance of the base struct and/or for the raw $type$ of the data failed</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Create a new empty array of </span><code>int</code><span>s and another of </span><code>void*</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* DynamicArray of integers */</span><span>
DynamicArray_int </span><span class="code_operators">*</span><span>dynarr_i;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr_i, </span><span class="code_numbers">0</span><span>, </span><span class="code_constants">NULL</span><span>);

</span><span class="code_comments">/* DynamicArray of pointers to void */</span><span>
</span><span class="code_keywords">typedef</span><span> </span><span class="code_keywords">struct</span><span> {</span><span class="code_types">int</span><span> i; </span><span class="code_types">float</span><span> f;} Item;
DynamicArray_void_ptr </span><span class="code_operators">*</span><span>dynarr_vp;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr_vp, </span><span class="code_keywords">sizeof</span><span>(Item</span><span class="code_operators">*</span><span>), </span><span class="code_numbers">0</span><span>, </span><span class="code_constants">NULL</span><span>);
</span></code></pre><br/><p class="info note"><span>a shorthand version of the above can also be used:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* DynamicArray of integers */</span><span>
DynamicArray_int </span><span class="code_operators">*</span><span>dynarr_i;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr_i);

</span><span class="code_comments">/* DynamicArray of pointers to void */</span><span>
</span><span class="code_keywords">typedef</span><span> </span><span class="code_keywords">struct</span><span> {</span><span class="code_types">int</span><span> i; </span><span class="code_types">float</span><span> f;} Item;
DynamicArray_void_ptr </span><span class="code_operators">*</span><span>dynarr_vp;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr_vp, </span><span class="code_keywords">sizeof</span><span>(Item</span><span class="code_operators">*</span><span>));
</span></code></pre><br/><p class="info note"><span>Create a new DynamicArray of </span><code>double</code><span>s filled with a single </span><code>double</code><span>:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_types">double</span><span> number </span><span class="code_operators">=</span><span> </span><span class="code_numbers">.1234</span><span>;
DynamicArray_double </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">1</span><span>, </span><span class="code_operators">&amp;</span><span>number);
</span></code></pre><br/><p class="info note"><span>Create a new DynamicArray of </span><code>float</code><span>s filled with 4 </span><code>float</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_types">float</span><span> numbers[] </span><span class="code_operators">=</span><span> {</span><span class="code_numbers">1.f</span><span>, </span><span class="code_numbers">2.f</span><span>, </span><span class="code_numbers">3.f</span><span>, </span><span class="code_numbers">4.f</span><span>};
DynamicArray_float </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">4</span><span>, </span><span class="code_operators">&amp;</span><span>numbers);
</span></code></pre><br/><p class="info note"><span>Don't forget to check if the creation of the DynamicArray was successful:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#define</span><span> CHARS </span><span class="code_strings">"dennis ritchie"</span><span>
DynamicArray_char </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, (</span><span class="code_keywords">sizeof</span><span> CHARS) </span><span class="code_operators">-</span><span> </span><span class="code_numbers">1</span><span>, CHARS))
{
    </span><span class="code_functions">fprintf</span><span>(</span><span class="code_constants">stderr</span><span>, </span><span class="code_strings">"Internal allocation failed\n"</span><span>);
}
</span></code></pre><br/></div><div class="entity" id="func_del"><p><span class="name">del</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>del</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray and deletes the object and all of its content.</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/></div><div class="entity" id="func_print"><p><span class="name">print</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">print</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">char*(*</span><span class="space_arg_type_name"> </span><span class="arg_name">formatter</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(const type*, char**, size_t*)</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>print</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific DynamicArray and prints its content formatted.
Internally it is using the format string notation of the standard
library, and all the basic C and </span><code>cutils</code><span> types prints out with the
proper formatting. It is also extended with some user-friendly
representation, like the </span><code>bool</code><span> values, the </span><code>char</code><span> and </span><code>char*</code><span>s or the
generic </span><code>void*</code><span>s.
</span><br/><span></span><br/><span>
It is also possible to pass a custom formatter as the second argument,
which makes it possible to format user-defined types. This </span><code>formatter</code><span>
callback function takes a pointer to type, a pointer to pointer to
</span><code>char</code><span> which points to a dynamically allocated buffer and a pointer
to a </span><code>size_t</code><span> which is the size of the allcoated buffer (which size is
128 </span><code>char</code><span>s by default). The </span><code>formatter</code><span> function can resize this
buffer (and it will be resized until the print function returns) or it
can change the pointer to point to other values. (For example, if the
object contains pointers to </span><code>char</code><span>s, it would be unefficient to copy
the string of each value.) For each item the passed pointer will
always point to the default buffer, even the pointer was changed for
the previous item.
</span><br/><span></span><br/><span>
</span><b><i><span>Note 1:</span></i></b><span> Do not </span><code>free()</code><span> the buffer, it will be automatically
</span><code>free</code><span>'d at the end of the </span><code>print</code><span> funtion. If the buffer is </span><code>free</code><span>'d
before the </span><code>print</code><span> function printed all the content of the object, it
is very likely that the program will crash with a </span><code>SEGMENTATION FAULT</code><span>.
</span><br/><span></span><br/><span>
</span><b><i><span>Note 2:</span></i></b><span> If </span><code>print</code><span> is used on a </span><code>DynamicArray_char_ptr</code><span>, all
</span><code>char*</code><span>s need to be null-terminated, otherwise the function call
will produce undefined-behaviour. It is highly recommended, to use
the </span><a class="inline_link" href="cstr.html"><span></span><code>String</code><span></span></a><span> object in case of literal purposes.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">internal allocation failed</code><p class="exception_note"><span>The allocation of space in memory for the instance of the base struct and/or for the raw $type$ of the data failed</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Different types of DynamicArrays have different representations:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* DynamicArray of pointers to bools */</span><span>
DynamicArray_bool </span><span class="code_operators">*</span><span>dynarr_b;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr_b, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">bool</span><span>[]){</span><span class="code_constants">true</span><span>, </span><span class="code_constants">false</span><span>, </span><span class="code_constants">false</span><span>, </span><span class="code_constants">true</span><span>, </span><span class="code_constants">true</span><span>})))
    </span><span class="code_functions">print</span><span>(dynarr_b);

</span><span class="code_comments">/* DynamicArray of pointers to doubles */</span><span>
DynamicArray_double </span><span class="code_operators">*</span><span>dynarr_d;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr_d, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">double</span><span>[]){</span><span class="code_numbers">2.5</span><span>, </span><span class="code_numbers">17.257</span><span>, </span><span class="code_numbers">65.537</span><span>, </span><span class="code_numbers">42.9496</span><span>})))
    </span><span class="code_functions">print</span><span>(dynarr_d);

</span><span class="code_comments">/* DynamicArray of pointers to chars */</span><span>
DynamicArray_char </span><span class="code_operators">*</span><span>dynarr_c;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr_c, </span><span class="code_numbers">6</span><span>, ((</span><span class="code_types">char</span><span>[]){'\n', '\t', '\\', </span><span class="code_strings">'\'</span><span>', '\</span><span class="code_numbers">0</span><span>', </span><span class="code_strings">'"'</span><span>})))
    </span><span class="code_functions">print</span><span>(dynarr_c);

</span><span class="code_comments">/* DynamicArray of pointers to pointer to char */</span><span>
DynamicArray_char_ptr </span><span class="code_operators">*</span><span>dynarr_cp;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr_cp, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">char</span><span></span><span class="code_operators">*</span><span>[]){</span><span class="code_strings">"Talk is cheap.\nShow me the code.\n"</span><span>
                                  </span><span class="code_strings">"\t--\tLinus Torvalds\a"</span><span>})));
    </span><span class="code_functions">print</span><span>(dynarr_cp);

</span><span class="code_comments">/* DynamicArray of pointers to pointer to void */</span><span>
DynamicArray_void_ptr </span><span class="code_operators">*</span><span>dynarr_vp;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr_vp, </span><span class="code_keywords">sizeof</span><span>(</span><span class="code_types">int</span><span> </span><span class="code_operators">*</span><span>), </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">void</span><span></span><span class="code_operators">*</span><span>[]){</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">int</span><span>){</span><span class="code_numbers">55</span><span>},
                                                 </span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">int</span><span>){</span><span class="code_numbers">77</span><span>},
                                                 </span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">int</span><span>){</span><span class="code_numbers">99</span><span>}})))
    </span><span class="code_functions">print</span><span>(dynarr_vp);

</span><span class="code_functions">del</span><span>(dynarr_b);
</span><span class="code_functions">del</span><span>(dynarr_d);
</span><span class="code_functions">del</span><span>(dynarr_c);
</span><span class="code_functions">del</span><span>(dynarr_cp);
</span><span class="code_functions">del</span><span>(dynarr_vp);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_bool{true, false, false, true, true}
DynamicArray_double{2.500000, 17.257000, 65.537000, 42.949600}
DynamicArray_char{'\n', '\t', '\\', '\'', '\0', '"'}
DynamicArray_char_ptr{"Talk is cheap.\nShow me the code.\n", "\t--\tLinus Torvalds\a"}
DynamicArray_void_ptr{&lt;pointer to 0x7fe5c0403b58&gt;, &lt;pointer to 0x7fe5c0403b68&gt;, &lt;pointer to 0x7fe5c0403b78&gt;}</code></pre><br/><p class="info note"><span>Using the custom formatter callback function to print out the content of a </span><code>DynamicArray_void_ptr</code><span> storing user-defined </span><code>Object</code><span> type items
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Base type */</span><span>
</span><span class="code_keywords">typedef</span><span> </span><span class="code_keywords">struct</span><span>
{
    </span><span class="code_types">bool</span><span> hidden;
    </span><span class="code_types">float</span><span> value;
} Object;



</span><span class="code_comments">/* Formatter callback */</span><span>
</span><span class="code_keywords">static</span><span> </span><span class="code_types">bool</span><span>
</span><span class="code_functions">Object_repr</span><span>(</span><span class="code_keywords">const</span><span> Object </span><span class="code_operators">*</span><span>object,
            </span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>buffer,
            </span><span class="code_types">size_t</span><span> </span><span class="code_operators">*</span><span>buffer_size)
{
</span><span class="code_macros">    #define</span><span> </span><span class="code_functions">REPR</span><span>(value) </span><span class="code_strings">"Object{"</span><span> value </span><span class="code_strings">"}"</span><span>
</span><span class="code_macros">    #define</span><span> HIDDEN </span><span class="code_functions">REPR</span><span>(</span><span class="code_strings">"HIDDEN"</span><span>)
</span><span class="code_macros">    #define</span><span> PUBLIC </span><span class="code_functions">REPR</span><span>(</span><span class="code_strings">".f=%f"</span><span>)
    
    </span><span class="code_comments">/* Number of digits needed by the float value */</span><span>
    </span><span class="code_types">size_t</span><span> public_size </span><span class="code_operators">=</span><span> </span><span class="code_functions">snprintf</span><span>(</span><span class="code_constants">NULL</span><span>, </span><span class="code_numbers">0</span><span>, </span><span class="code_strings">"%f"</span><span>, object</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>value) </span><span class="code_operators">+</span><span> </span><span class="code_keywords">sizeof</span><span> PUBLIC;
    
    </span><span class="code_comments">/* Resize buffer if necessary */</span><span>
    </span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span>(</span><span class="code_operators">*</span><span>buffer_size </span><span class="code_operators">&gt;</span><span></span><span class="code_operators">=</span><span> public_size </span><span class="code_operators">&amp;</span><span></span><span class="code_operators">&amp;</span><span> </span><span class="code_operators">*</span><span>buffer_size </span><span class="code_operators">&gt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_keywords">sizeof</span><span> HIDDEN))
    {
        </span><span class="code_comments">/* If resize failed */</span><span>
        </span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span>(</span><span class="code_operators">*</span><span>buffer </span><span class="code_operators">=</span><span> </span><span class="code_functions">realloc</span><span>(</span><span class="code_operators">*</span><span>buffer, public_size)))
            </span><span class="code_keywords">return</span><span> </span><span class="code_constants">false</span><span>;
        </span><span class="code_operators">*</span><span>buffer_size </span><span class="code_operators">=</span><span> public_size;
    }
    
    </span><span class="code_comments">/* Format string representation*/</span><span>
    </span><span class="code_keywords">if</span><span> (object</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>hidden)
        </span><span class="code_functions">snprintf</span><span>(</span><span class="code_operators">*</span><span>buffer, </span><span class="code_operators">*</span><span>buffer_size, HIDDEN);
    </span><span class="code_keywords">else</span><span>
        </span><span class="code_functions">snprintf</span><span>(</span><span class="code_operators">*</span><span>buffer, </span><span class="code_operators">*</span><span>buffer_size, PUBLIC, object</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>value);
    </span><span class="code_keywords">return</span><span> </span><span class="code_constants">true</span><span>;
}



</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
    </span><span class="code_types">bool</span><span> check;
    
    DynamicArray_void_ptr </span><span class="code_operators">*</span><span>objects;
    check </span><span class="code_operators">=</span><span> </span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>objects, </span><span class="code_keywords">sizeof</span><span>(Object), </span><span class="code_numbers">2</span><span>, ((Object[]){{</span><span class="code_operators">.</span><span>hidden</span><span class="code_operators">=</span><span></span><span class="code_constants">true</span><span>,  </span><span class="code_operators">.</span><span>value</span><span class="code_operators">=</span><span></span><span class="code_numbers">42.f</span><span>},
                                                         {</span><span class="code_operators">.</span><span>hidden</span><span class="code_operators">=</span><span></span><span class="code_constants">false</span><span>, </span><span class="code_operators">.</span><span>value</span><span class="code_operators">=</span><span></span><span class="code_numbers">3.14f</span><span>}}));
    </span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span>check)
    {
        </span><span class="code_functions">fprintf</span><span>(</span><span class="code_constants">stderr</span><span>, </span><span class="code_strings">"Allocation failed\n"</span><span>);
        </span><span class="code_keywords">return</span><span> </span><span class="code_constants">EXIT_FAILURE</span><span>;
    }
    </span><span class="code_functions">print</span><span>(objects, Object_repr);
    
    </span><span class="code_functions">del</span><span>(objects);
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray{Object{HIDDEN}, Object{.f=3.140000}}</code></pre><br/></div><div class="entity" id="func_data"><p><span class="name">data</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t *</span><span class="space_arg_type_name"> </span><span class="arg_name">byte_size</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t *</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>data</code><span> is a type-generic function-like macro, which takes a pointer to a DynamicArray, and two pointers to </span><code>size_t</code><span>. Returns a properly casted pointer to the raw array, (except for </span><code>DynamicArray_void_ptr</code><span>, it returns a </span><code>void **</code><span>), and writes the byte size of all data stored in array to </span><code>byte_size</code><span> (Not the allocated memory size of the array) and the number of items stored in the array to </span><code>item_count</code><span>.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>type *</span></code><span class="return_case">:</span><span>A properly casted pointer to the raw array data on success</span><br/></p><table class="return_values"><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if one of the arguments are not valid</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">2nd argument is NULL</code><p class="exception_note"><span>Function cannot write to a </span><code>NULL</code><span> pointer</span></p><br/><code class="exception_message">3rd argument is NULL</code><p class="exception_note"><span>Function cannot write to a </span><code>NULL</code><span> pointer</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get data of array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Declare variables */</span><span>
</span><span class="code_types">size_t</span><span> size, count;
DynamicArray_float </span><span class="code_operators">*</span><span>dynarr;

</span><span class="code_comments">/* Create array */</span><span>
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">float</span><span>[]){</span><span class="code_numbers">1.2f</span><span>, </span><span class="code_numbers">3.4f</span><span>, </span><span class="code_numbers">5.6f</span><span>, </span><span class="code_numbers">7.8f</span><span>}));
</span><span class="code_comments">/* Get raw data and infos */</span><span>
</span><span class="code_types">float</span><span> </span><span class="code_operators">*</span><span>array </span><span class="code_operators">=</span><span> </span><span class="code_functions">data</span><span>(dynarr, </span><span class="code_operators">&amp;</span><span>size, </span><span class="code_operators">&amp;</span><span>count);

</span><span class="code_comments">/* Iterate through the raw data */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"size of array: %zu byte(s)\n"</span><span>, size);
</span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>count; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"[%zu] %.1f\n"</span><span>, i, array[i]);
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">size of array: 16 byte(s)
[0] 1.2
[1] 3.4
[2] 5.6
[3] 7.8</code></pre><br/></div><div class="entity" id="func_raw"><p><span class="name">raw</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>raw</code><span> is a type-generic function-like macro, which takes a pointer to a DynamicArray. Returns a properly casted pointer to the raw array, (except for </span><code>DynamicArray_void_ptr</code><span> it returns a </span><code>void **</code><span>).
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>type *</span></code><span class="return_case">:</span><span>A properly casted pointer to the raw array data on success</span><br/></p><table class="return_values"><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if one of the arguments are not valid</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get raw data:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Declare variables */</span><span>
DynamicArray_char_ptr </span><span class="code_operators">*</span><span>dynarr;

</span><span class="code_comments">/* Create array */</span><span>
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>[]){(</span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>){</span><span class="code_strings">"My God, it's full of stars"</span><span>},
                            (</span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>){</span><span class="code_strings">"David Bowman"</span><span>}}));
</span><span class="code_comments">/* Get and print raw data */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"%s!\n"</span><span>, </span><span class="code_functions">raw</span><span>(dynarr)[</span><span class="code_numbers">0</span><span>]);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"-- %s\n"</span><span>, </span><span class="code_functions">raw</span><span>(dynarr)[</span><span class="code_numbers">1</span><span>]);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">My God, it's full of stars!
-- David Bowman</code></pre><br/></div><div class="entity" id="func_len"><p><span class="name">len</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>len</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, and returns the number of items stored in the array (the length of the array).
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Number of items in the array</span></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get length of array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array of unsigned longs */</span><span>
DynamicArray_unsigned_long </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">unsigned</span><span> </span><span class="code_types">long</span><span>[]){</span><span class="code_numbers">75ul</span><span>, </span><span class="code_numbers">44ul</span><span>, </span><span class="code_numbers">79ul</span><span>, </span><span class="code_numbers">125ul</span><span>, </span><span class="code_numbers">68ul</span><span>}));

</span><span class="code_comments">/* Check length of array */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Number of items in array: %zu\n"</span><span>, </span><span class="code_functions">len</span><span>(dynarr));

</span><span class="code_comments">/* Destroy array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Number of items in array: 5</code></pre><br/></div><div class="entity" id="func_size"><p><span class="name">size</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>size</code><span> is a type-generic function-like macro, which takes a pointer to
a type-specific DynamicArray, and returns the byte size of all the
items stored in the array. (Not the allocated memory size of the
array). It is basically identical to something like this:
</span><br/><span>
</span><code>size_t bytes = sizeof(item_type_in_array) * len(dynamic_array);</code><span>
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Byte size of the array</span></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get and print byte size of an array:</span></p><br/><pre class="info"><code class="snippet"><span>DynamicArray_unsigned_long_long </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">unsigned</span><span> </span><span class="code_types">long</span><span> </span><span class="code_types">long</span><span>[]){</span><span class="code_numbers">9ull</span><span>, </span><span class="code_numbers">8ull</span><span>, </span><span class="code_numbers">7ull</span><span>, </span><span class="code_numbers">6ull</span><span>}));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Size of array: %zu byte(s)\n"</span><span>, </span><span class="code_functions">size</span><span>(dynarr));
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Size of array: 32 byte(s)</code></pre><br/></div><div class="entity" id="func_clear"><p><span class="name">clear</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>clear</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific DynamicArray and makes it empty. Because this function does not destroy the previously stored data, only makes the "slots" available to store new data again; and because it does not shrink the size of the array either, it is considered to be a good practice to clear an existing dynamic array if it is not in use anymore and use that array to store new data in it, so the array does not have to allocate the memory again, therefore it is more efficient in speed, but probably takes more space in the memory.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get length of array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create and fill array */</span><span>
DynamicArray_signed_char </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">signed</span><span> </span><span class="code_types">char</span><span>[]){</span><span class="code_operators">-</span><span></span><span class="code_numbers">5</span><span>, </span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">5</span><span>}));

</span><span class="code_comments">/* Check length array */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Number of items in array: %zu\n"</span><span>, </span><span class="code_functions">len</span><span>(dynarr));
</span><span class="code_functions">clear</span><span>(dynarr);

</span><span class="code_comments">/* Check length array */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Number of items in array: %zu\n"</span><span>, </span><span class="code_functions">len</span><span>(dynarr));

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Number of items in array: 3
Number of items in array: 0</code></pre><br/></div><div class="entity" id="func_resize"><p><span class="name">resize</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>resize</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, and the preferred size of the array (the number of items it should take without continous reallocation) and forces the array to pre-allocate enough space for the given amount of elements. If the preferred size is lesser than the current size of the array, the array will be truncated.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if array already has the given size, or if reallocation was successful</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if array was not initialised or the internal allocation failed'</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">array is not initialised</code><p class="exception_note"><span>function cannot operate on </span><code>NULL</code><span> pointer</span></p><br/><code class="exception_message">internal reallocation failed</code><p class="exception_note"><span>reallocating the data in memory failed</span></p><br/></div><div class="entity" id="func_swap"><p><span class="name">swap</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index1</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index2</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">swap</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index1</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index2</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>swap</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, an index to the first element of the first block, another index to the first element of the second block, and the number of elements in the blocks and swaps the two blocks inside the array. </span><code>swap</code><span> also has a variant, where the last argument can be dropped and it will be passed as the defualt </span><code>1</code><span>.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the swapping was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if there was nothing to swap (indices are the same, the array is empty, etc.) or the swap was successful
</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if array is a pointer to </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if one of the indices is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>The 1st index passed is greater than the number of items in the array.</span></p><br/><code class="exception_message">3rd argument is out of range</code><p class="exception_note"><span>The 2nd index passed is greater than the number of items in the array.</span></p><br/><code class="exception_message">blocks are overlapping</code><p class="exception_note"><span>It is more like a warning or note: the passed count argument is greater than the number of items between the two indices. The execution of the function will continue and the function will use the maximum available number of items to swap, so one can ignore this exception.
</span></p><br/><code class="exception_message">4th argument is out of range</code><p class="exception_note"><span>The count argument is greater than the number of items between the greater index and the end of the array. The execution of the function will continue and the function will use the maximum available number of items to swap, so one can ignore this exception.
</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Swap a single </span><code>unsigned integer</code><span> in array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create, fill and print array */</span><span>
DynamicArray_unsigned_int </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">unsigned</span><span>[]){</span><span class="code_numbers">3u</span><span>, </span><span class="code_numbers">9u</span><span>, </span><span class="code_numbers">6u</span><span>, </span><span class="code_numbers">12u</span><span>}));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Before swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Swap elements and print array again */</span><span>
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">swap</span><span>(dynarr, </span><span class="code_numbers">1</span><span>, </span><span class="code_numbers">2</span><span>))
  </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Oups! Something went wrong during swapping.."</span><span>);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"\nAfter swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Destroy array and its content */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Before swap:
DynamicArray_unsigned_int{3, 9, 6, 12}

After swap:
DynamicArray_unsigned_int{3, 6, 9, 12}</code></pre><br/><p class="info note"><span>Swap blocks of </span><code>long</code><span>s in array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create, fill and print array */</span><span>
DynamicArray_long </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">6</span><span>, ((</span><span class="code_types">long</span><span>[]){</span><span class="code_numbers">13l</span><span>, </span><span class="code_numbers">21l</span><span>, </span><span class="code_numbers">5l</span><span>, </span><span class="code_numbers">8l</span><span>, </span><span class="code_numbers">2l</span><span>, </span><span class="code_numbers">3l</span><span>}));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Before swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Swap elements and print array again */</span><span>
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">swap</span><span>(dynarr, </span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">4</span><span>, </span><span class="code_numbers">2</span><span>))
  </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Oh, snap.. Not again!"</span><span>);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"\nAfter swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Destroy array and its content */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Before swap:
DynamicArray_long{13, 21, 5, 8, 2, 3}

After swap:
DynamicArray_long{2, 3, 5, 8, 13, 21}</code></pre><br/></div><div class="entity" id="func_reverse"><p><span class="name">reverse</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>reverse</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray and reverses the content of the array.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the reversing was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if array has been successfully reversed</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if array is a pointer to </span><code>NULL</code><span></span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Reversing an array of </span><code>size_t</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array */</span><span>
DynamicArray_size_t </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">6</span><span>, ((</span><span class="code_types">size_t</span><span>[]){</span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">5</span><span>, </span><span class="code_numbers">10</span><span>, </span><span class="code_numbers">15</span><span>, </span><span class="code_numbers">20</span><span>, </span><span class="code_numbers">25</span><span>}));

</span><span class="code_comments">/* Reverse array */</span><span>
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_functions">reverse</span><span>(dynarr);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_size_t{0, 5, 10, 15, 20, 25}
DynamicArray_size_t{25, 20, 15, 10, 5, 0}</code></pre><br/></div><div class="entity" id="func_append"><p><span class="name">append</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">append</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>append</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray and a pointer to a single item or the number of items and a pointer to the items and appends the item(s) at the end of the array.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the addition was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if item(s) was/were successfully appended to the array</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if array is a pointer to </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if internal reallocation failed</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">3rd argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">internal reallocation failed</code><p class="exception_note"><span>The function could not reallocate more space in the memory for the new item(s)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>First append two items, then a single one to an initially empty array of </span><code>char</code><span>s
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array */</span><span>
DynamicArray_char </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr);

</span><span class="code_comments">/* Append to array */</span><span>
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_functions">append</span><span>(dynarr, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">char</span><span>[]){</span><span class="code_strings">'u'</span><span>, </span><span class="code_strings">'v'</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_functions">append</span><span>(dynarr, (</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">char</span><span>){</span><span class="code_strings">'w'</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_char{}
DynamicArray_char{'u', 'v'}
DynamicArray_char{'u', 'v', 'w'}</code></pre><br/><p class="info note"><span>Adding pointers to </span><code>NULL</code><span> to </span><code>DynamicArray_void_ptr</code><span>:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Base values */</span><span>
</span><span class="code_types">int</span><span>   i, j, k;
</span><span class="code_types">float</span><span> l, m;

</span><span class="code_comments">/* Create a array from a pointer to NULL and pointers to int */</span><span>
DynamicArray_void_ptr </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_keywords">sizeof</span><span>(</span><span class="code_types">void</span><span></span><span class="code_operators">*</span><span>), </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>[]){</span><span class="code_constants">NULL</span><span>, </span><span class="code_operators">&amp;</span><span>i, </span><span class="code_operators">&amp;</span><span>j, </span><span class="code_operators">&amp;</span><span>k}));

</span><span class="code_comments">/* Append a single pointer to NULL */</span><span>
</span><span class="code_functions">append</span><span>(dynarr, (</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>){</span><span class="code_constants">NULL</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Append two more pointers to floats */</span><span>
</span><span class="code_functions">append</span><span>(dynarr, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">void</span><span></span><span class="code_operators">*</span><span>[]){</span><span class="code_operators">&amp;</span><span>l, </span><span class="code_operators">&amp;</span><span>m}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_void_ptr{&lt;pointer to NULL&gt;, &lt;pointer to 0x7f8c30d00048&gt;, &lt;pointer to 0x7f8c30d00058&gt;, &lt;pointer to 0x7f8c30d00068&gt;, &lt;pointer to NULL&gt;}
DynamicArray_void_ptr{&lt;pointer to NULL&gt;, &lt;pointer to 0x7f8c30d00048&gt;, &lt;pointer to 0x7f8c30d00058&gt;, &lt;pointer to 0x7f8c30d00068&gt;, &lt;pointer to NULL&gt;, &lt;pointer to 0x7f8c30d00108&gt;, &lt;pointer to 0x7f8c30d00118&gt;}</code></pre><br/></div><div class="entity" id="func_push"><p><span class="name">push</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">push</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>push</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific DynamicArray, an index, a pointer to the source and
optionally the number of items. It inserts item(s) before the given
index and shifts the data already there.
</span><br/><span></span><br/><span>
</span><b><i><span>Note:</span></i></b><span> Why </span><code>push</code><span> and </span><code>pull</code><span> instead of the more intuitive
</span><code>insert</code><span> and </span><code>remove</code><span>? The main reason, is because the standard
library already uses the function name </span><code>remove</code><span> in </span><code>stdio</code><span>. Of course
dispatching between the standard and the cutils calls would be easy. (One
has to add a </span><code>const char *</code><span> to the </span><code>_Generic</code><span> assocation list of this
function.) However using an alternative version, </span><code>pull</code><span>, is still a nicer
solution. Besides, it is even shorter! And to keep the naming consistent,
if </span><code>remove</code><span>'s pair is </span><code>insert</code><span>, then </span><code>pull</code><span>'s pair is </span><code>push</code><span>!
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the insertion was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if item(s) was/were successfully inserted to the array</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if array is a pointer to </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if internal reallocation failed</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">4th argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">internal reallocation failed</code><p class="exception_note"><span>The function could not reallocate more space in the memory for the new item(s)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Insert a single item at the second place of the array, then insert two more at the beginning of the array
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array */</span><span>
DynamicArray_short </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">short</span><span>[]){(</span><span class="code_types">short</span><span>)</span><span class="code_numbers">3</span><span>, (</span><span class="code_types">short</span><span>)</span><span class="code_numbers">5</span><span>, (</span><span class="code_types">short</span><span>)</span><span class="code_numbers">6</span><span>, (</span><span class="code_types">short</span><span>)</span><span class="code_numbers">7</span><span>}));

</span><span class="code_comments">/* Insert items into array */</span><span>
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_functions">push</span><span>(dynarr, </span><span class="code_numbers">1</span><span>, (</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">short</span><span>){</span><span class="code_numbers">4</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_functions">push</span><span>(dynarr, </span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">short</span><span>[]){(</span><span class="code_types">short</span><span>)</span><span class="code_numbers">1</span><span>, (</span><span class="code_types">short</span><span>)</span><span class="code_numbers">2</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_short{3, 5, 6, 7}
DynamicArray_short{3, 4, 5, 6, 7}
DynamicArray_short{1, 2, 3, 4, 5, 6, 7}</code></pre><br/></div><div class="entity" id="func_pull"><p><span class="name">pull</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">pull</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>pull</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific DynamicArray, an index, and optionally the number
items, and it will remove it/them from the array.
</span><br/><span></span><br/><span>
</span><b><i><span>Note:</span></i></b><span> Why </span><code>push</code><span> and </span><code>pull</code><span> instead of the more intuitive
</span><code>insert</code><span> and </span><code>remove</code><span>? The main reason, is because the standard
library already uses the function name </span><code>remove</code><span> in </span><code>stdio</code><span>. Of course
dispatching between the standard and the cutils calls would be easy. (One
has to add a </span><code>const char *</code><span> to the </span><code>_Generic</code><span> assocation list of this
function.) However using an alternative version, </span><code>pull</code><span>, is still a nicer
solution. Besides, it is even shorter! And to keep the naming consistent,
if </span><code>remove</code><span>'s pair is </span><code>insert</code><span>, then </span><code>pull</code><span>'s pair is </span><code>push</code><span>!
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Indicates the number of items has been successfully removed.</span><br/></p><table class="return_values"><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if index out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Remove the last item, then the second and third ones from the array
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array */</span><span>
DynamicArray_bool </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">bool</span><span>[]){</span><span class="code_constants">true</span><span>, </span><span class="code_constants">false</span><span>, </span><span class="code_constants">false</span><span>, </span><span class="code_constants">true</span><span>, </span><span class="code_constants">false</span><span>}));

</span><span class="code_comments">/* Remove items from array */</span><span>
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_functions">pull</span><span>(dynarr, </span><span class="code_functions">len</span><span>(dynarr) </span><span class="code_operators">-</span><span> </span><span class="code_numbers">1</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_functions">pull</span><span>(dynarr, </span><span class="code_numbers">1</span><span>, </span><span class="code_numbers">2</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_bool{true, false, false, true, false}
DynamicArray_bool{true, false, false, true}
DynamicArray_bool{true, true}</code></pre><br/></div><div class="entity" id="func_pop"><p><span class="name">pop</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">destination</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">pop</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">destination</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>pop</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, an index, a pointer to type of destination and optionally the number of items to pop. It will remove the items specified by the index from the array and copy it to the destination.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Indicates the number of items has been successfully popped.</span><br/></p><table class="return_values"><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer to array is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer destination is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if array is empty</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>index</code><span> is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">4th argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Pop out a single item, and then another two from the array
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array */</span><span>
DynamicArray_double </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">double</span><span>[]){</span><span class="code_numbers">23.974624</span><span>, </span><span class="code_numbers">10.</span><span>, </span><span class="code_numbers">86.666667</span><span>, </span><span class="code_numbers">3.14</span><span>, </span><span class="code_numbers">.56</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Create destination storages */</span><span>
</span><span class="code_macros">#define</span><span> NUMS </span><span class="code_numbers">3</span><span>
</span><span class="code_types">double</span><span> number;
</span><span class="code_types">double</span><span> numbers[NUMS];

</span><span class="code_comments">/* Pop a single item from array to destination */</span><span>
</span><span class="code_functions">pop</span><span>(dynarr, </span><span class="code_numbers">0</span><span>, </span><span class="code_operators">&amp;</span><span>number);
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"popped: %lf\n"</span><span>, number);

</span><span class="code_comments">/* Pop a multiple items from array to destination */</span><span>
</span><span class="code_functions">pop</span><span>(dynarr, </span><span class="code_numbers">1</span><span>, NUMS, numbers);
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>NUMS; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"popped [%zu] %lf\n"</span><span>, i, numbers[i]);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_double{23.974624, 10.000000, 86.666667, 3.140000, 0.560000}
DynamicArray_double{10.000000, 10.000000, 86.666667, 3.140000}
popped: 23.974624
DynamicArray_double{10.000000}
popped [0] 10.000000
popped [1] 86.666667
popped [2] 3.140000</code></pre><br/></div><div class="entity" id="func_sub"><p><span class="name">sub</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">destination</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">sub</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">destination</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>sub</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, an index, a pointer to type of destination and optionally the number of items to sub-copy. It will copy the items specified by the index from the array to the destination.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Indicates the number of items has been successfully copied.</span><br/></p><table class="return_values"><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer to array is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer destination is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if array is empty</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>index</code><span> is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">4th argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Copy a single item, and then five other items from the array
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array */</span><span>
DynamicArray_long_long </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">6</span><span>, ((</span><span class="code_types">long</span><span> </span><span class="code_types">long</span><span>[]){</span><span class="code_numbers">11ll</span><span>, </span><span class="code_numbers">22ll</span><span>, </span><span class="code_numbers">33ll</span><span>, </span><span class="code_numbers">44ll</span><span>, </span><span class="code_numbers">55ll</span><span>, </span><span class="code_numbers">66ll</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Create destination storages */</span><span>
</span><span class="code_macros">#define</span><span> NUMS </span><span class="code_numbers">5</span><span>
</span><span class="code_types">long</span><span> </span><span class="code_types">long</span><span> number;
</span><span class="code_types">long</span><span> </span><span class="code_types">long</span><span> numbers[NUMS];

</span><span class="code_comments">/* Pop a single item from array to destination */</span><span>
</span><span class="code_functions">sub</span><span>(dynarr, </span><span class="code_numbers">2</span><span>, </span><span class="code_operators">&amp;</span><span>number);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"copied: %lld\n"</span><span>, number);

</span><span class="code_comments">/* Pop a multiple item from array to destination */</span><span>
</span><span class="code_functions">sub</span><span>(dynarr, </span><span class="code_numbers">1</span><span>, NUMS, numbers);
</span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>NUMS; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"copied: [%zu] %lld\n"</span><span>, i, numbers[i]);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_long_long{11, 22, 33, 44, 55, 66}
copied: 33
copied: [0] 22
copied: [1] 33
copied: [2] 44
copied: [3] 55
copied: [4] 66
DynamicArray_long_long{11, 22, 33, 44, 55, 66}</code></pre><br/></div><div class="entity" id="func_truncate"><p><span class="name">truncate</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>truncate</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray and an index. It removes all items starts from the index.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Truncating from the last element, and then from the second element
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Variables */</span><span>
</span><span class="code_types">int</span><span> a, b, c, d, e;

</span><span class="code_comments">/* Create array */</span><span>
DynamicArray_ptrdiff_t </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">ptrdiff_t</span><span>[]){</span><span class="code_operators">&amp;</span><span>a </span><span class="code_operators">-</span><span> </span><span class="code_operators">&amp;</span><span>d, </span><span class="code_operators">&amp;</span><span>e </span><span class="code_operators">-</span><span> </span><span class="code_operators">&amp;</span><span>b, </span><span class="code_operators">&amp;</span><span>b </span><span class="code_operators">-</span><span> </span><span class="code_operators">&amp;</span><span>c, </span><span class="code_operators">&amp;</span><span>d </span><span class="code_operators">-</span><span> </span><span class="code_operators">&amp;</span><span>b}));

</span><span class="code_comments">/* Truncate array from the item befire the last one */</span><span>
</span><span class="code_functions">print</span><span>(dynarr);
</span><span class="code_functions">truncate</span><span>(dynarr, </span><span class="code_functions">len</span><span>(dynarr) </span><span class="code_operators">-</span><span> </span><span class="code_numbers">2</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Truncate array from the first item */</span><span>
</span><span class="code_functions">truncate</span><span>(dynarr, </span><span class="code_numbers">1</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_ptrdiff_t{3, -3, 1, -2}
DynamicArray_ptrdiff_t{3, -3}
DynamicArray_ptrdiff_t{3}</code></pre><br/></div><div class="entity" id="func_set"><p><span class="name">set</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">set</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>set</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, and index, a pointer to type as source and optionally the number of items. It sets the item/items at/starts from the given index in array.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the settings was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if all items were set</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer to array is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>item</code><span>/</span><code>items</code><span> is pointing to </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>index</code><span> is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">4th argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Set a single item, and then three other items in the array
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array */</span><span>
DynamicArray_int </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">7</span><span>, ((</span><span class="code_types">int</span><span>[]){</span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">7</span><span>, </span><span class="code_numbers">2</span><span>, </span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">2</span><span>, </span><span class="code_numbers">1</span><span>, </span><span class="code_numbers">6</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Set second item in array */</span><span>
</span><span class="code_functions">set</span><span>(dynarr, </span><span class="code_numbers">1</span><span>, (</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">int</span><span>){</span><span class="code_numbers">1</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Set three items starting from the third item in array */</span><span>
</span><span class="code_functions">set</span><span>(dynarr, </span><span class="code_numbers">3</span><span>, </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">int</span><span>[]){</span><span class="code_numbers">3</span><span>, </span><span class="code_numbers">4</span><span>, </span><span class="code_numbers">5</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_int{0, 7, 2, 0, 2, 1, 6}
DynamicArray_int{0, 1, 2, 0, 2, 1, 6}
DynamicArray_int{0, 1, 2, 3, 4, 5, 6}</code></pre><br/></div><div class="entity" id="func_get"><p><span class="name">get</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>get</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray and an index. It returns a properly casted to type item, except for </span><code>DynamicArray_void_ptr</code><span>, where it returns a pointer to the pointer stored in the array.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>type *</span></code><span class="return_case">:</span><span>returns a properly casted to type item</span><br/></p><table class="return_values"><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if pointer to arrat is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if array is empty</span></td></tr><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>index</code><span> is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get each </span><code>float</code><span> and the next one from the array and add them:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array */</span><span>
</span><span class="code_macros">#define</span><span> SIZE </span><span class="code_numbers">4</span><span>
DynamicArray_float </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, SIZE, ((</span><span class="code_types">float</span><span>[]){</span><span class="code_numbers">4.78</span><span>, </span><span class="code_numbers">99.</span><span>, </span><span class="code_numbers">13.62</span><span>, </span><span class="code_numbers">.123</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Add together all items and their neighbours from the array */</span><span>
</span><span class="code_types">float</span><span> a, b;
</span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>SIZE </span><span class="code_operators">-</span><span> </span><span class="code_numbers">1</span><span>; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
{
    a </span><span class="code_operators">=</span><span> </span><span class="code_functions">get</span><span>(dynarr, i);
    b </span><span class="code_operators">=</span><span> </span><span class="code_functions">get</span><span>(dynarr, i </span><span class="code_operators">+</span><span> </span><span class="code_numbers">1</span><span>);
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"%.2f + %.2f = %.2f\n"</span><span>, a, b, a </span><span class="code_operators">+</span><span> b);
}

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_float{4.780000, 99.000000, 13.620000, 0.123000}
4.78 + 99.00 = 103.78
99.00 + 13.62 = 112.62
13.62 + 0.12 = 13.74</code></pre><br/></div><div class="entity" id="func_map"><p><span class="name">map</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">void (*</span><span class="space_arg_type_name"> </span><span class="arg_name">function</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(size_t, type*)</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span><br/><span class="name">map</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">void (*</span><span class="space_arg_type_name"> </span><span class="arg_name">function</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(size_t, type*)</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>map</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray and a function. It will call the function on every item in the array. It can also take two more optional arguments: an </span><code>index</code><span> which is where the mapping starts from, and a </span><code>count</code><span> which indicates how many items the function will be called on.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is greater than the length of the array</span></p><br/><code class="exception_message">4th argument is out of range</code><p class="exception_note"><span>if the </span><code>function</code><span> argument is pointing to </span><code>NULL</code><span></span></p><br/><p class="info label">Examples:</p><p class="info note"><span></span><i><span>Rotate</span></i><span> all characters by 13 in the array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_keywords">static</span><span> </span><span class="code_types">void</span><span>
</span><span class="code_functions">rot13</span><span>(</span><span class="code_types">size_t</span><span> index, </span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>letter)
{
    </span><span class="code_types">int</span><span> upper </span><span class="code_operators">=</span><span> </span><span class="code_functions">toupper</span><span>(</span><span class="code_operators">*</span><span>letter);
    </span><span class="code_keywords">if</span><span> (upper </span><span class="code_operators">&gt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_strings">'A'</span><span> </span><span class="code_operators">&amp;</span><span></span><span class="code_operators">&amp;</span><span> upper </span><span class="code_operators">&lt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_strings">'M'</span><span>)
        </span><span class="code_operators">*</span><span>letter </span><span class="code_operators">+</span><span></span><span class="code_operators">=</span><span> </span><span class="code_numbers">13</span><span>;
    </span><span class="code_keywords">else</span><span> </span><span class="code_keywords">if</span><span> (upper </span><span class="code_operators">&gt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_strings">'N'</span><span> </span><span class="code_operators">&amp;</span><span></span><span class="code_operators">&amp;</span><span> upper </span><span class="code_operators">&lt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_strings">'Z'</span><span>)
        </span><span class="code_operators">*</span><span>letter </span><span class="code_operators">-</span><span></span><span class="code_operators">=</span><span> </span><span class="code_numbers">13</span><span>;
}



</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
    DynamicArray_char </span><span class="code_operators">*</span><span>dynarr;
    </span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">char</span><span>[]){</span><span class="code_strings">'a'</span><span>, </span><span class="code_strings">'b'</span><span>, </span><span class="code_strings">'c'</span><span>, </span><span class="code_strings">'d'</span><span>, </span><span class="code_strings">'e'</span><span>}));
    </span><span class="code_functions">print</span><span>(dynarr);
    
    </span><span class="code_functions">map</span><span>(dynarr, rot13);
    </span><span class="code_functions">print</span><span>(dynarr);
    
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_char{'a', 'b', 'c', 'd', 'e'}
DynamicArray_char{'n', 'o', 'p', 'q', 'r'}</code></pre><br/></div><div class="entity" id="func_find"><p><span class="name">find</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">const type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t *</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">find</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">bool(*</span><span class="space_arg_type_name"> </span><span class="arg_name">compare</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(const void*, const void*, size_t)</span><span class="space_arg_type_name"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">const type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t *</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>find</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, a pointer to type item and a pointer to the storage of the index. It searches for the first appeareance of the given item in the array, and writes the index of it to </span><code>index</code><span>.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if item is in the array or not.</span></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">3rd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Search for standard type in array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create array */</span><span>
DynamicArray_long_double </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">long</span><span> </span><span class="code_types">double</span><span>[]){</span><span class="code_numbers">5.14</span><span>, </span><span class="code_numbers">784.1</span><span>, </span><span class="code_numbers">12.</span><span>, </span><span class="code_numbers">5.477</span><span>, </span><span class="code_numbers">11.31</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">/* Values and variables */</span><span>
</span><span class="code_types">size_t</span><span> index;
</span><span class="code_types">long</span><span> </span><span class="code_types">double</span><span> number </span><span class="code_operators">=</span><span> </span><span class="code_numbers">12.</span><span>;

</span><span class="code_comments">/* Find number in array */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Is '%Lf' in array? "</span><span>, number);
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">find</span><span>(dynarr, </span><span class="code_operators">&amp;</span><span>number, </span><span class="code_operators">&amp;</span><span>index))
      </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"True. =&gt; [%zu] %Lf\n"</span><span>, index, </span><span class="code_functions">get</span><span>(dynarr, index));
</span><span class="code_keywords">else</span><span>
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"False.\n"</span><span>);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_long_double{5.140000, 784.100000, 12.000000, 5.477000, 11.310000}
Is '12.000000' in list? True. =&gt; [2] 12.000000</code></pre><br/><p class="info note"><span>Using a user-defined function to find first appearance of a user-type:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Base type */</span><span>
</span><span class="code_keywords">typedef</span><span> </span><span class="code_keywords">union</span><span>
{
    </span><span class="code_types">long</span><span> value;
    </span><span class="code_types">bool</span><span> truth;
} Data;



</span><span class="code_comments">/* Comparing function */</span><span>
</span><span class="code_keywords">static</span><span> </span><span class="code_keywords">inline</span><span> </span><span class="code_types">bool</span><span>
</span><span class="code_functions">compare_data</span><span>(</span><span class="code_keywords">const</span><span> </span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>p1,
             </span><span class="code_keywords">const</span><span> </span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>p2,
             </span><span class="code_types">size_t</span><span> size)
{
    </span><span class="code_keywords">return</span><span> </span><span class="code_operators">*</span><span>(</span><span class="code_types">long</span><span> </span><span class="code_operators">*</span><span>)p1 </span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span> (</span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>(Data </span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>)p2)</span><span class="code_operators">.</span><span>value;
}



</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
    </span><span class="code_comments">/* Create array */</span><span>
    DynamicArray_void_ptr </span><span class="code_operators">*</span><span>data;
    </span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>data, </span><span class="code_keywords">sizeof</span><span>(Data</span><span class="code_operators">*</span><span>), </span><span class="code_numbers">3</span><span>, ((Data</span><span class="code_operators">*</span><span>[]){</span><span class="code_operators">&amp;</span><span>(Data){</span><span class="code_operators">.</span><span>value</span><span class="code_operators">=</span><span> </span><span class="code_numbers">19l</span><span>},
                                            </span><span class="code_operators">&amp;</span><span>(Data){</span><span class="code_operators">.</span><span>value</span><span class="code_operators">=</span><span></span><span class="code_numbers">243l</span><span>},
                                            </span><span class="code_operators">&amp;</span><span>(Data){</span><span class="code_operators">.</span><span>value</span><span class="code_operators">=</span><span>  </span><span class="code_numbers">5l</span><span>}}));
    </span><span class="code_functions">print</span><span>(data);
    
    </span><span class="code_comments">/* Print index of first appearance */</span><span>
    </span><span class="code_types">size_t</span><span> index;
    </span><span class="code_keywords">if</span><span> (</span><span class="code_functions">find</span><span>(data, compare_data, </span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">long</span><span>){</span><span class="code_numbers">243l</span><span>}, </span><span class="code_operators">&amp;</span><span>index))
        </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"[%zu] %lu\n"</span><span>, index, (</span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>(Data </span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>)</span><span class="code_functions">get</span><span>(data, index))</span><span class="code_operators">.</span><span>value);
    
    </span><span class="code_comments">/* Delete array */</span><span>
    </span><span class="code_functions">del</span><span>(data);
    
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_void_ptr{&lt;pointer to 0x7fcfd14038e0&gt;, &lt;pointer to 0x7fcfd14038e8&gt;, &lt;pointer to 0x7fcfd14038f0&gt;}
[1] 243</code></pre><br/></div><div class="entity" id="func_findall"><p><span class="name">findall</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">const type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t *</span><span class="space_arg_type_name"> </span><span class="arg_name">indices</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">findall</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">bool(*</span><span class="space_arg_type_name"> </span><span class="arg_name">compare</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(const void*, const void*, size_t)</span><span class="space_arg_type_name"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">const type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t *</span><span class="space_arg_type_name"> </span><span class="arg_name">indices</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>findall</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, a pointer to type item and a pointer to the storage of the indices. It searches for all appearances of the given item in the array, and writes all indices of it to </span><code>indices</code><span>.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Indicates the number of indices found.</span></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">3rd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Find all appearances of </span><code>(unsigned char)3</code><span> in array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#define</span><span> CHARS </span><span class="code_numbers">7</span><span>

</span><span class="code_comments">/* Create array */</span><span>
DynamicArray_unsigned_char </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, CHARS, ((</span><span class="code_types">unsigned</span><span> </span><span class="code_types">char</span><span>[]){</span><span class="code_numbers">15</span><span>, </span><span class="code_numbers">9</span><span>, </span><span class="code_numbers">3</span><span>, </span><span class="code_numbers">3</span><span>, </span><span class="code_numbers">78</span><span>, </span><span class="code_numbers">67</span><span>, </span><span class="code_numbers">3</span><span>}));
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_types">unsigned</span><span> </span><span class="code_types">char</span><span> number </span><span class="code_operators">=</span><span> </span><span class="code_numbers">3</span><span>;
</span><span class="code_types">size_t</span><span> indices[CHARS],
       found </span><span class="code_operators">=</span><span> </span><span class="code_functions">findall</span><span>(dynarr, </span><span class="code_operators">&amp;</span><span>number, indices);

</span><span class="code_comments">/* Find number in array */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Where is '%uu' in the array?\n"</span><span>, number);
</span><span class="code_keywords">if</span><span> (found)
    </span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>found; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
        </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"It is at index [%zu].\n"</span><span>, indices[i]);
</span><span class="code_keywords">else</span><span>
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"It is not in the array.\n"</span><span>);

</span><span class="code_comments">/* Delete array */</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_unsigned_char{15, 9, 3, 3, 78, 67, 3}
Where is '3' in the array?
It is at index [2]
It is at index [3]
It is at index [6]</code></pre><br/><p class="info note"><span>Using a user-defined function to find all appearances of an item:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>ctype</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#define</span><span> </span><span class="code_functions">SIZE </span><span>(</span><span class="code_types">size_t</span><span>)</span><span class="code_numbers">64</span><span>

</span><span class="code_comments">/* Base type */</span><span>
</span><span class="code_keywords">typedef</span><span> </span><span class="code_keywords">struct</span><span>
{
    </span><span class="code_types">char</span><span> name[SIZE];
    </span><span class="code_types">int</span><span> power;
} Spell;



</span><span class="code_comments">/* Comparing function */</span><span>
</span><span class="code_keywords">static</span><span> </span><span class="code_keywords">inline</span><span> </span><span class="code_types">bool</span><span>
</span><span class="code_functions">compare_spells</span><span>(</span><span class="code_keywords">const</span><span> </span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>p1,
               </span><span class="code_keywords">const</span><span> </span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>p2,
               </span><span class="code_types">size_t</span><span> size)
{
    </span><span class="code_types">size_t</span><span> i;
    </span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>str;
    </span><span class="code_types">char</span><span> buffer[SIZE];

    str </span><span class="code_operators">=</span><span> (</span><span class="code_operators">*</span><span>(Spell </span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>)p2)</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>name;
    </span><span class="code_keywords">for</span><span> (i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>SIZE; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>) buffer[i] </span><span class="code_operators">=</span><span> </span><span class="code_functions">tolower</span><span>(str[i]);

    </span><span class="code_keywords">return</span><span> </span><span class="code_operators">!</span><span></span><span class="code_functions">strncmp</span><span>((</span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>)p1, buffer, SIZE);
}



</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
</span><span class="code_macros">    #define</span><span> SPELLS </span><span class="code_numbers">4</span><span>
    
    </span><span class="code_comments">/* Create array */</span><span>
    DynamicArray_void_ptr </span><span class="code_operators">*</span><span>spells;
    </span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>spells, </span><span class="code_keywords">sizeof</span><span>(Spell</span><span class="code_operators">*</span><span>), SPELLS, ((Spell</span><span class="code_operators">*</span><span>[]){</span><span class="code_operators">&amp;</span><span>(Spell){</span><span class="code_operators">.</span><span>name</span><span class="code_operators">=</span><span></span><span class="code_strings">"Geminio"</span><span>, </span><span class="code_operators">.</span><span>power</span><span class="code_operators">=</span><span> </span><span class="code_numbers">81</span><span>},
                                                     </span><span class="code_operators">&amp;</span><span>(Spell){</span><span class="code_operators">.</span><span>name</span><span class="code_operators">=</span><span></span><span class="code_strings">"accio"</span><span>,   </span><span class="code_operators">.</span><span>power</span><span class="code_operators">=</span><span> </span><span class="code_numbers">64</span><span>},
                                                     </span><span class="code_operators">&amp;</span><span>(Spell){</span><span class="code_operators">.</span><span>name</span><span class="code_operators">=</span><span></span><span class="code_strings">"imperio"</span><span>, </span><span class="code_operators">.</span><span>power</span><span class="code_operators">=</span><span></span><span class="code_numbers">144</span><span>},
                                                     </span><span class="code_operators">&amp;</span><span>(Spell){</span><span class="code_operators">.</span><span>name</span><span class="code_operators">=</span><span></span><span class="code_strings">"ACCIO"</span><span>,   </span><span class="code_operators">.</span><span>power</span><span class="code_operators">=</span><span> </span><span class="code_numbers">64</span><span>}}));
    </span><span class="code_functions">print</span><span>(spells);
    
    </span><span class="code_comments">/* Search for spell in array */</span><span>
    </span><span class="code_types">size_t</span><span> indices[SPELLS];
    </span><span class="code_types">size_t</span><span> index,
           found </span><span class="code_operators">=</span><span> </span><span class="code_functions">findall</span><span>(spells, compare_spells, (</span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>)</span><span class="code_strings">"accio"</span><span>, indices);
    
    </span><span class="code_comments">/* Print all indices */</span><span>
    </span><span class="code_keywords">if</span><span> (found)
        </span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>found; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
        {
            index </span><span class="code_operators">=</span><span> indices[i];
            </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"[%zu] %s\n"</span><span>, index, (</span><span class="code_operators">*</span><span>(Spell </span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>)</span><span class="code_functions">get</span><span>(spells, index))</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>name);
        }
    
    </span><span class="code_comments">/* Delete array */</span><span>
    </span><span class="code_functions">del</span><span>(spells);
    
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_void_ptr{&lt;pointer to 0x7fd642d00000&gt;, &lt;pointer to 0x7fd642d00008&gt;, &lt;pointer to 0x7fd642d00010&gt;, &lt;pointer to 0x7fd642d00018&gt;}
[1] accio
[3] ACCIO</code></pre><br/></div></div></div></div></body></html>