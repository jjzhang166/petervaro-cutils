<html><!-- www.cutils.org | Peter Varo | 2014 --><head><link href="http://www.cutils.org/favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="http://www.cutils.org/favicon.ico" rel="icon" type="image/x-icon"/><title>CDAR Dynamic Array</title><meta charset="utf-8"/><link href="css/cdoc.css" rel="stylesheet" type="text/css"/></head><body><div id="column1"><div id="generic"><img src="img/cutils.svg"/><br/><h2><span>MODERN AND LIGHTWEIGHT C UTILITIES</span></h2><p><span>&mdash;</span></p><p><span>DESIGNED BY</span></p><p><span>PETER VARO &copy;2014</span></p><p><span>&mdash;</span></p><br/></div><div id="sidebar"><div><p class="label">Modules:</p></div><br/><a class="toc" href="index.html">CUTILS</a><a class="toc" href="c11.html">C11 Syntax Highlighter</a><a class="toc" href="cref.html">CREF Quick Reference</a><a class="toc" href="cenv.html">CENV Environment Generator</a><a class="toc" href="cdep.html">CDEP Dependeny Graph</a><a class="toc" href="ccom.html">CCOM Comment Scanner</a><a class="toc" href="cver.html">CVER Versioning</a><a class="toc" href="clic.html">CLIC License Comment Generator</a><a class="toc" href="cres.html">CRES External Resources Packer</a><a class="toc" href="carg.html">CARG Variadic Argument Macro</a><a class="toc" href="cbug.html">CBUG Debugging &amp; Logging</a><a class="toc" href="cexc.html">CEXC Exception Handling</a><a class="toc" href="cpro.html">CPRO Profiling</a><a class="toc" href="cutt.html">CUTT Unit Testing Tools</a><a class="toc toc_current" href="#">CDAR Dynamic Array</a><a class="toc" href="cstr.html">CSTR Strings</a><a class="toc" href="csll.html">CSLL Single Linked List</a><a class="toc" href="cdll.html">CDLL Double Linked List</a><a class="toc" href="cmap.html">CMAP HashMap</a><a class="toc" href="cfps.html">CFPS Frame Per Second</a><a class="toc" href="ccol.html">CCOL Color Helper</a><a class="toc" href="cdoc.html">CDOC Documenting Tool</a><br/><div><p class="label">Options:</p><br/><a class="toc" href="#user_Name_Mangling">Name Mangling</a></div><br/><div><p class="label">Types:</p><br/><a class="toc" href="#type_DynamicArray_char">DynamicArray_char</a><a class="toc" href="#type_DynamicArray_string">DynamicArray_string</a><a class="toc" href="#type_DynamicArray_String">DynamicArray_String</a><a class="toc" href="#type_DynamicArray_int">DynamicArray_int</a><a class="toc" href="#type_DynamicArray_short">DynamicArray_short</a><a class="toc" href="#type_DynamicArray_long">DynamicArray_long</a><a class="toc" href="#type_DynamicArray_long_long">DynamicArray_long_long</a><a class="toc" href="#type_DynamicArray_unsigned">DynamicArray_unsigned</a><a class="toc" href="#type_DynamicArray_unsigned_long">DynamicArray_unsigned_long</a><a class="toc" href="#type_DynamicArray_unsigned_long_long">DynamicArray_unsigned_long_long</a><a class="toc" href="#type_DynamicArray_float">DynamicArray_float</a><a class="toc" href="#type_DynamicArray_double">DynamicArray_double</a><a class="toc" href="#type_DynamicArray_long_double">DynamicArray_long_double</a><a class="toc" href="#type_DynamicArray_void">DynamicArray_void</a></div><br/><div><p class="label">Functions:</p><br/><a class="toc" href="#func_new">new()</a><a class="toc" href="#func_del">del()</a><a class="toc" href="#func_print">print()</a><a class="toc" href="#func_data">data()</a><a class="toc" href="#func_raw">raw()</a><a class="toc" href="#func_len">len()</a><a class="toc" href="#func_size">size()</a><a class="toc" href="#func_clear">clear()</a><a class="toc" href="#func_resize">resize()</a><a class="toc" href="#func_swap">swap()</a></div></div></div><div id="column2"><div id="content"><h1><span>CDAR | Dynamic Array</span></h1><br/><p><span>...
</span></p><br/><div><h2 class="title">Options</h2><div class="entity" id="user_Name_Mangling"><p class="name">Name Mangling</p><br/><p class="info"><span>However </span><code>cutils</code><span> uses very short and expressive function names which
are not confronting with any of the standard library's entities,
sometimes one wants to use some of these function, macro or type
names in one's own project for other purposes. To solve this problem
</span><code>cutils</code><span> provides a macro variable, a flag, to turn on or off the
prefixes of the variable names. By default it is turned off.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Each public function or function-like macro, or type name will have the same </span><code>cutils_</code><span> prefix, as follows
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_functions">append</span><span>();  </span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">&gt;</span><span>  </span><span class="code_functions">cutils_append</span><span>();
</span></code></pre><br/><p class="info note"><span>One can compile all files or just some of it, defining the variable through the </span><code>-D</code><span> flag of the compiler, like this
:</span></p><br/><pre class="info"><code class="snippet">cc -std=c11 -Wall -DCUTILS_NAMESPACE -c -o filename.o</code></pre><br/><p class="info note"><span>Or one can define this variable before the inclusion of a header file:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#define</span><span> CUTILS_NAMESPACE
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cdar</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#undef</span><span> CUTILS_NAMESPACE</span></code></pre><br/></div><div><h2 class="title">Types</h2><div class="entity" id="type_DynamicArray_char"><span class="name">DynamicArray_char</span><span class="arg_paren"> &lt; </span><span class="arg_type">char</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>char</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_string"><span class="name">DynamicArray_string</span><span class="arg_paren"> &lt; </span><span class="arg_type">char *</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>char *</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_String"><span class="name">DynamicArray_String</span><span class="arg_paren"> &lt; </span><span class="arg_type">String</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>String</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_int"><span class="name">DynamicArray_int</span><span class="arg_paren"> &lt; </span><span class="arg_type">int</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>int</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_short"><span class="name">DynamicArray_short</span><span class="arg_paren"> &lt; </span><span class="arg_type">short</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>short</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_long"><span class="name">DynamicArray_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">long</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>long</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_long_long"><span class="name">DynamicArray_long_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">long long</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>long long</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_unsigned"><span class="name">DynamicArray_unsigned</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>unsigned</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_unsigned_long"><span class="name">DynamicArray_unsigned_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned long</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>unsigned long</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_unsigned_long_long"><span class="name">DynamicArray_unsigned_long_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned long long</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>unsigned long long</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_float"><span class="name">DynamicArray_float</span><span class="arg_paren"> &lt; </span><span class="arg_type">float</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>float</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_double"><span class="name">DynamicArray_double</span><span class="arg_paren"> &lt; </span><span class="arg_type">double</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>double</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_long_double"><span class="name">DynamicArray_long_double</span><span class="arg_paren"> &lt; </span><span class="arg_type">long double</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>long double</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div><div class="entity" id="type_DynamicArray_void"><span class="name">DynamicArray_void</span><span class="arg_paren"> &lt; </span><span class="arg_type">void *</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>A dynamic array type, to contain </span><code>void *</code><span> type of items. It must be declared as a pointer, pointing to </span><code>NULL</code><span>.
</span></p><br/></div></div><div><h2 class="title">Functions</h2><div class="entity" id="func_new"><p><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type **</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type **</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>new()</code><span> is a type-generic function-like macro, which takes a pointer to pointer to a type-specific DynamicArray to create a new array. The new array can be initialised with arbitrary number of data.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if array was created successfully</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if internal allocation failed</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">internal allocation failed</code><p class="exception_note"><span>The allocation of space in memory for the instance of the base struct and/or for the raw array of the data failed
</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Create a new empty dynamic array of </span><code>int</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span>DynamicArray_int </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">0</span><span>, </span><span class="code_constants">NULL</span><span>);
</span></code></pre><br/><p class="info note"><span>a shorthand version can also be used:</span></p><br/><pre class="info"><code class="snippet"><span>DynamicArray_int </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr);
</span></code></pre><br/><p class="info note"><span>Create a new empty DynamicArray of </span><code>char</code><span>s with preallocated space for 40 </span><code>char</code><span>s
:</span></p><br/><pre class="info"><code class="snippet"><span>DynamicArray_char </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">40</span><span>, </span><span class="code_constants">NULL</span><span>);
</span></code></pre><br/><p class="info note"><span>Create a new DynamicArray of </span><code>double</code><span>s filled with a single </span><code>double</code><span>:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_types">double</span><span> number </span><span class="code_operators">=</span><span> </span><span class="code_numbers">.1234</span><span>;
DynamicArray_double </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">1</span><span>, </span><span class="code_operators">&amp;</span><span>number);
</span></code></pre><br/><p class="info note"><span>Create a new DynamicArray of </span><code>float</code><span>s filled with 4 </span><code>float</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_types">float</span><span> numbers[] </span><span class="code_operators">=</span><span> {</span><span class="code_numbers">1.f</span><span>, </span><span class="code_numbers">2.f</span><span>, </span><span class="code_numbers">3.f</span><span>, </span><span class="code_numbers">4.f</span><span>};
DynamicArray_float </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">4</span><span>, </span><span class="code_operators">&amp;</span><span>numbers);
</span></code></pre><br/></div><div class="entity" id="func_del"><p><span class="name">del</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>del()</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray and deletes it and all of its content.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/></div><div class="entity" id="func_print"><p><span class="name">print</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">print</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">void(*)(size_t, void *)</span><span class="space_arg_type_name"> </span><span class="arg_name">call_back</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>print()</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray and pretty prints its content. Internally it is using the format string notation of the standard library, and all the basic C and </span><code>cutils</code><span> types prints out with the proper formatting. For </span><code>DynamicArray_void</code><span> prints out the items as pointers (</span><code>"%p"</code><span>).
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Examples:</p><p class="info note"><span>Print out the content of array of </span><code>float</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">// Create and fill array</span><span>
DynamicArray_float </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">float</span><span>[]){</span><span class="code_numbers">3.14f</span><span>, </span><span class="code_numbers">1.59f</span><span>, </span><span class="code_numbers">2.65f</span><span>, </span><span class="code_numbers">3.58f</span><span>, </span><span class="code_numbers">9.79f</span><span>}));

</span><span class="code_comments">// Pretty print content of array</span><span>
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">// Destroy array</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_float
{
    [0] 3.140000
    [1] 1.590000
    [2] 2.650000
    [3] 3.580000
    [4] 9.790000
}</code></pre><br/><p class="info note"><span>The </span><code>print()</code><span> also provides an interface to pass a custom call back function to format the user defined data types. The next example shows how to pretty print a </span><code>DynamicArray_void</code><span> which contains pointers to a type called </span><code>Struct</code><span>
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">// Base Type</span><span>
</span><span class="code_keywords">typedef</span><span> </span><span class="code_keywords">struct</span><span> { </span><span class="code_types">int</span><span> i; </span><span class="code_types">float</span><span> f; } Struct;

</span><span class="code_comments">// Callback function</span><span>
</span><span class="code_keywords">static</span><span> </span><span class="code_types">void</span><span>
</span><span class="code_functions">Struct_print</span><span>(</span><span class="code_types">size_t</span><span> index,
             Struct </span><span class="code_operators">*</span><span>item)
{
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"\t[%zu] Struct {.i=%d, .f=%.2f}\n"</span><span>, index, item</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>i, item</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>f);
}

</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
    </span><span class="code_comments">// Create, fill and print array</span><span>
    DynamicArray_void </span><span class="code_operators">*</span><span>dynarr;
    </span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">3</span><span>, ((Struct</span><span class="code_operators">*</span><span>[]){</span><span class="code_operators">&amp;</span><span>(Struct){</span><span class="code_operators">.</span><span>i</span><span class="code_operators">=</span><span></span><span class="code_numbers">12</span><span>, </span><span class="code_operators">.</span><span>f</span><span class="code_operators">=</span><span></span><span class="code_numbers">2.33</span><span>},
                                 </span><span class="code_operators">&amp;</span><span>(Struct){</span><span class="code_operators">.</span><span>i</span><span class="code_operators">=</span><span></span><span class="code_numbers">19</span><span>, </span><span class="code_operators">.</span><span>f</span><span class="code_operators">=</span><span></span><span class="code_numbers">6.97</span><span>},
                                 </span><span class="code_operators">&amp;</span><span>(Struct){</span><span class="code_operators">.</span><span>i</span><span class="code_operators">=</span><span></span><span class="code_numbers">44</span><span>, </span><span class="code_operators">.</span><span>f</span><span class="code_operators">=</span><span></span><span class="code_numbers">1.03</span><span>}}));
    </span><span class="code_comments">// Print content of array</span><span>
    </span><span class="code_functions">print</span><span>(dynarr, Struct_print);
    
    </span><span class="code_comments">// Destroy array and its content</span><span>
    </span><span class="code_functions">del</span><span>(dynarr);
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">DynamicArray_void
{
    [0] Struct {.i=12, .f=2.33}
    [1] Struct {.i=19, .f=6.97}
    [2] Struct {.i=44, .f=1.03}
}</code></pre><br/></div><div class="entity" id="func_data"><p><span class="name">data</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t *</span><span class="space_arg_type_name"> </span><span class="arg_name">byte_size</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t *</span><span class="space_arg_type_name"> </span><span class="arg_name">item count</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>data()</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, and two pointers to </span><code>size_t</code><span> data, and returns a properly casted pointer to the raw array, and also tells the byte size and the number of items in the array.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>type *</span></code><span class="return_case">:</span><span>A properly casted pointer to the raw array data on success</span><br/></p><table class="return_values"><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if one of the arguments are not valid</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">array is not initialised</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will happen)
</span></p><br/><code class="exception_message">2nd argument is NULL</code><p class="exception_note"><span>Function cannot write to a </span><code>NULL</code><span> pointer</span></p><br/><code class="exception_message">3rd argument is NULL</code><p class="exception_note"><span>Function cannot write to a </span><code>NULL</code><span> pointer</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get data of array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">// Declare variables</span><span>
</span><span class="code_types">size_t</span><span> size, count;
DynamicArray_float </span><span class="code_operators">*</span><span>dynarr;

</span><span class="code_comments">// Create array</span><span>
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">float</span><span>[]){</span><span class="code_numbers">1.2f</span><span>, </span><span class="code_numbers">3.4f</span><span>, </span><span class="code_numbers">5.6f</span><span>, </span><span class="code_numbers">7.8f</span><span>}));
</span><span class="code_comments">// Get raw data and infos</span><span>
</span><span class="code_types">float</span><span> </span><span class="code_operators">*</span><span>array </span><span class="code_operators">=</span><span> </span><span class="code_functions">data</span><span>(dynarr, </span><span class="code_operators">&amp;</span><span>size, </span><span class="code_operators">&amp;</span><span>count);

</span><span class="code_comments">// Iterate through raw data</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"size of array: %zu byte\n"</span><span>, size);
</span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>count; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"[%zu] %.1f\n"</span><span>, i, array[i]);
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">size of array: 16 byte
[0] 1.2
[1] 3.4
[2] 5.6
[3] 7.8</code></pre><br/></div><div class="entity" id="func_raw"><p><span class="name">raw</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>raw()</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, and returns a properly casted pointer to the raw array.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>type *</span></code><span class="return_case">:</span><span>A properly casted pointer to the raw array data on success</span><br/></p><table class="return_values"><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if one of the arguments are not valid</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">array is not initialised</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will happen)
</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get raw data:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">// Declare variables</span><span>
</span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>str </span><span class="code_operators">=</span><span> </span><span class="code_strings">"hello world"</span><span>;
DynamicArray_string </span><span class="code_operators">*</span><span>dynarr;

</span><span class="code_comments">// Create array</span><span>
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">1</span><span>, </span><span class="code_operators">&amp;</span><span>str);
</span><span class="code_comments">// Get and print raw data</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"%s!\n"</span><span>, </span><span class="code_functions">raw</span><span>(dynarr)[</span><span class="code_numbers">0</span><span>]);
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">hello world!</code></pre><br/></div><div class="entity" id="func_len"><p><span class="name">len</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>len()</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, and returns the number of items stored in the array (the length of it).
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Number of items in the array</span></p><br/><p class="info label">Exceptions:</p><code class="exception_message">array is not initialised</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will happen)
</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get and print length of an array:</span></p><br/><pre class="info"><code class="snippet"><span>DynamicArray_char </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">char</span><span>[]){</span><span class="code_strings">'a'</span><span>, </span><span class="code_strings">'b'</span><span>, </span><span class="code_strings">'c'</span><span>}));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Number of items: %zu\n"</span><span>, </span><span class="code_functions">len</span><span>(dynarr));
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Number of items: 3</code></pre><br/></div><div class="entity" id="func_size"><p><span class="name">size</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>size()</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific DynamicArray, and returns the byte size of all the
items stored in the array. (Not the allocated memory size of the
array). It is basically identical to something like this:
</span><br/><span>
</span><code>size_t bytes = sizeof(item_type_in_array) * len(dynamic_array);</code><span>
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Byte size of the array</span></p><br/><p class="info label">Exceptions:</p><code class="exception_message">array is not initialised</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will happen)
</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get and print byte size of an array:</span></p><br/><pre class="info"><code class="snippet"><span>DynamicArray_unsigned_long_long </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">unsigned</span><span> </span><span class="code_types">long</span><span> </span><span class="code_types">long</span><span>[]){</span><span class="code_numbers">9ull</span><span>, </span><span class="code_numbers">8ull</span><span>, </span><span class="code_numbers">7ull</span><span>, </span><span class="code_numbers">6ull</span><span>}));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Size of array: %zu byte(s)\n"</span><span>, </span><span class="code_functions">size</span><span>(dynarr));
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Size of array: 32 byte(s)</code></pre><br/></div><div class="entity" id="func_clear"><p><span class="name">clear</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>clear()</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific DynamicArray, which makes an array empty. Because
this function does not destroy the previously stored data, only makes
the "slots" available to store new data again; and because it does not
shrink the size of the array either, it is considered to be a good
practice to clear an existing dynamic array if it is not in use
anymore and use that array to store new data, so the array does not
have to allocate the memory again, therefore it is more efficient in
speed, but probably takes more space in the memory.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Exceptions:</p><code class="exception_message">array is not initialised</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATIO FAULT</code><span> error will happen)
</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Create an array of </span><code>float</code><span>s, fill the array and then remove all items:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">// Create and fill array</span><span>
DynamicArray_float </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">float</span><span>[]){</span><span class="code_numbers">5.f</span><span>, </span><span class="code_numbers">6.f</span><span>, </span><span class="code_numbers">7.f</span><span>}));

</span><span class="code_comments">// Check length</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Number of items in array: %zu\n"</span><span>, </span><span class="code_functions">len</span><span>(dynarr));
</span><span class="code_comments">// Clear array</span><span>
</span><span class="code_functions">clear</span><span>(dynarr);
</span><span class="code_comments">// Check length again</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Number of items in array: %zu\n"</span><span>, </span><span class="code_functions">len</span><span>(dynarr));

</span><span class="code_comments">// Destroy array</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Number of items in array: 3
Number of items in array: 0</code></pre><br/></div><div class="entity" id="func_resize"><p><span class="name">resize</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>resize()</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, and the preferred size of the array (the number of items it should take) and forces the array to pre-allocate enough space for the given amount of elements.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if array already has the given size, or if reallocation was successful</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if array was not initialised or the internal allocation failed'</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">array is not initialised</code><p class="exception_note"><span>function cannot operate on </span><code>NULL</code><span> pointer</span></p><br/><code class="exception_message">internal reallocation failed</code><p class="exception_note"><span>reallocating the data in memory failed</span></p><br/></div><div class="entity" id="func_swap"><p><span class="name">swap</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index1</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index2</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">swap</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">DynamicArray_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">dynamic_array</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index1</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index2</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>swap()</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific DynamicArray, an index to the first element of the first block, another index to the first element of the second block, and the number of elements in the blocks and swaps the two blocks inside the array. </span><code>swap()</code><span> also has a variant, where the last argument can be dropped and it will be passed as the defualt </span><code>1</code><span>.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the swapping was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if there was nothing to swap (indices are the same, the array is empty, etc.) or the swap was successful
</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if array is a pointer to </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if one of the indices is out of range</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if internal allocation failed</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">array is not initialised</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will happen)
</span></p><br/><code class="exception_message">array is empty</code><p class="exception_note"><span>It is more like a warning or note: the passed array is empty, which may or may not what one wanted. The return value will also be </span><code>true</code><span> so one can ignore this exception.
</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>The 1st index passed is greater than the number of items in the array.</span></p><br/><code class="exception_message">3rd argument is out of range</code><p class="exception_note"><span>The 2nd index passed is greater than the number of items in the array.</span></p><br/><code class="exception_message">blocks are overlapping</code><p class="exception_note"><span>It is more like a warning or note: the passed count argument is greater than the number of items between the two indices. The execution of the function will continue and the function will use the maximum available number of items to swap, so one can ignore this exception.
</span></p><br/><code class="exception_message">4th argument is out of range</code><p class="exception_note"><span>The count argument is greater than the number of items between the greater index and the end of the array. The execution of the function will continue and the function will use the maximum available number of items to swap, so one can ignore this exception.
</span></p><br/><code class="exception_message">internal allocation failed</code><p class="exception_note"><span>The allocation of space in memory for temporary purposes failed.
</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Swap a single </span><code>unsigned integer</code><span> in array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">// Create, fill and print array</span><span>
DynamicArray_unsigned </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">unsigned</span><span>[]){</span><span class="code_numbers">9u</span><span>, </span><span class="code_numbers">6u</span><span>}));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Before swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">// Swap elements and print array again</span><span>
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">swap</span><span>(dynarr, </span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">1</span><span>))
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Oups! Something went wrong during swapping.."</span><span>);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"\nAfter swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">// Destroy array and its content</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Before swap:
DynamicArray_unsigned
{
    [0] 9
    [1] 6
}

After swap:
DynamicArray_unsigned
{
    [0] 6
    [1] 9
}</code></pre><br/><p class="info note"><span>Swap blocks of </span><code>long</code><span>s in array:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">// Create, fill and print array</span><span>
DynamicArray_long </span><span class="code_operators">*</span><span>dynarr;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>dynarr, </span><span class="code_numbers">6</span><span>, ((</span><span class="code_types">long</span><span>[]){</span><span class="code_numbers">13l</span><span>, </span><span class="code_numbers">21l</span><span>, </span><span class="code_numbers">5l</span><span>, </span><span class="code_numbers">8l</span><span>, </span><span class="code_numbers">2l</span><span>, </span><span class="code_numbers">3l</span><span>}));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Before swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">// Swap elements and print array again</span><span>
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">swap</span><span>(dynarr, </span><span class="code_numbers">1</span><span>, </span><span class="code_numbers">4</span><span>, </span><span class="code_numbers">2</span><span>))
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Oh, snap.. Not again!"</span><span>);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"\nAfter swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(dynarr);

</span><span class="code_comments">// Destroy array and its content</span><span>
</span><span class="code_functions">del</span><span>(dynarr);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Before swap:
DynamicArray_long
{
    [0] 13
    [1] 21
    [2] 5
    [3] 8
    [4] 2
    [5] 3
}

After swap:
DynamicArray_long
{
    [0] 2
    [1] 3
    [2] 5
    [3] 8
    [4] 13
    [5] 21
}</code></pre><br/></div></div></div></div></body></html>