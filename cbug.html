<html><!-- www.cutils.org | Peter Varo | 2014 --><head><link href="http://www.cutils.org/favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="http://www.cutils.org/favicon.ico" rel="icon" type="image/x-icon"/><title>CBUG Debugging &amp; Logging</title><meta charset="utf-8"/><link href="css/cdoc.css" rel="stylesheet" type="text/css"/></head><body><div id="column1"><div id="generic"><img src="img/cutils.svg"/><br/><h2><span>MODERN AND LIGHTWEIGHT C UTILITIES</span></h2><p><span>&mdash;</span></p><p><span>DESIGNED BY</span></p><p><span>PETER VARO &copy;2014</span></p><p><span>&mdash;</span></p><br/></div><div id="sidebar"><div><p class="label">Modules:</p></div><br/><a class="toc" href="index.html">CUTILS</a><a class="toc" href="c11.html">C11 Syntax Highlighter</a><a class="toc" href="cref.html">CREF Quick Reference</a><a class="toc" href="cenv.html">CENV Environment Generator</a><a class="toc" href="cdep.html">CDEP Dependeny Graph</a><a class="toc" href="ccom.html">CCOM Comment Scanner</a><a class="toc" href="cver.html">CVER Versioning</a><a class="toc" href="clic.html">CLIC License Comment Generator</a><a class="toc" href="cres.html">CRES External Resources Packer</a><a class="toc" href="capi.html">CAPI Interface</a><a class="toc" href="carg.html">CARG Variadic Argument Macro</a><a class="toc toc_current" href="#">CBUG Debugging &amp; Logging</a><a class="toc" href="cexc.html">CEXC Exception Handling</a><a class="toc" href="cpro.html">CPRO Profiling</a><a class="toc" href="cutt.html">CUTT Unit Testing Tools</a><a class="toc" href="cdar.html">CDAR Dynamic Array</a><a class="toc" href="cstr.html">CSTR Strings</a><a class="toc" href="csll.html">CSLL Singly Linked List</a><a class="toc" href="cdll.html">CDLL Doubly Linked List</a><a class="toc" href="cmap.html">CMAP HashMap</a><a class="toc" href="cfps.html">CFPS Frame Per Second</a><a class="toc" href="ccol.html">CCOL Color Helper</a><a class="toc" href="cdoc.html">CDOC Documenting Tool</a><a class="toc" href="call.html">CALL Include All</a><br/><div><p class="label">Options:</p><br/><a class="toc" href="#user_Name_Mangling">Name Mangling</a></div><br/><div><p class="label">Flags:</p><br/><a class="toc" href="#user_CBUG_OFF">CBUG_OFF</a></div><br/><div><p class="label">Functions:</p><br/><a class="toc" href="#func_debug">debug()</a><a class="toc" href="#func_boolean">boolean()</a></div></div></div><div id="column2"><div id="content"><h1><span>CBUG | Debugging and Logging</span></h1><br/><p><span>A very lightweight debugging/logging single header-only utility,
contains a single function-like macro which can print its
invocation place, a custom message or a formatted message with
values to the standard error output.
</span></p><br/><div><h2 class="title">Options</h2><div class="entity" id="user_Name_Mangling"><p class="name">Name Mangling</p><br/><p class="info"><span>However </span><code>cutils</code><span> uses very short and expressive function names which
are not confronting with any of the standard library's entities,
sometimes one wants to use some of these function, macro or type
names in one's own project for other purposes. To solve this problem
</span><code>cutils</code><span> provides a macro variable, a flag, to turn on or off the
prefixes of the variable names. By default it is turned off.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Each public function or function-like macro, or type name will have the same </span><code>cutils_</code><span> prefix, as follows
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_functions">debug</span><span>();  </span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">&gt;</span><span>  </span><span class="code_functions">cutils_debug</span><span>();
</span></code></pre><br/><p class="info note"><span>One can compile all files or just some of it, defining the variable through the </span><code>-D</code><span> flag of the compiler, like this
:</span></p><br/><pre class="info"><code class="snippet">cc -std=c11 -Wall -DCUTILS_NAMESPACE -c -o filename.o</code></pre><br/><p class="info note"><span>Or one can define this variable before the inclusion of the API header file
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cbug</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#define</span><span> CUTILS_NAMESPACE
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>capi</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span></code></pre><br/></div><div><h2 class="title">Flags</h2><div class="entity" id="user_CBUG_OFF"><p class="name">CBUG_OFF</p><br/><p class="info"><span>The </span><code>debug</code><span> macro can be turned off by defining an empty </span><code>CBUG_OFF</code><span>
macro variable before the include macro statement or by compiling
the the code with a </span><code>-DCBUG_OFF</code><span> flag. If this variable is defined
all the apperences of the </span><code>debug</code><span> macro will be removed from the
source file.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Defining variable before inclusion:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#define</span><span> CBUG_OFF
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cbug</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#undef</span><span> CBUG_OFF
</span></code></pre><br/></div><div><h2 class="title">Functions</h2><div class="entity" id="func_debug"><p><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">void</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span><br/><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">char *</span><span class="space_arg_type_name"> </span><span class="arg_name">message</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">String</span><span class="space_arg_type_name"> </span><span class="arg_name">message</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">char *</span><span class="space_arg_type_name"> </span><span class="arg_name">format_string</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type"></span><span class="space_arg_type_name"> </span><span class="arg_name">...</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>debug</code><span> has its own internal counter, which is scope based. (This
means, that each invocaition place's scope has its own counter.)
This counter increases each time when the function-like macro is
called. </span><code>debug</code><span> prints the value of the counter and the location
informations from where it was called.
</span><br/><span></span><br/><span>
</span><code>debug</code><span> can be called with a single argument, which has to be a
</span><code>char *</code><span> string. This message will be indented and printed out after
the default debugging line.
</span><br/><span></span><br/><span>
</span><code>debug</code><span> also can be called with 2+ arguments (up to 63 in total). In
this case the first argument has to be a format-string and all the
other arguments can be any type specified in the format-string. It
works exactly as the standard library's </span><code>printf</code><span> function. The
formatted message will be indented and printed out after the default
debugging line.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Examples:</p><p class="info note"><span>Calling </span><code>debug</code><span> in all 3 forms from the main function:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>stdio</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>        </span><span class="code_comments">/* fprintf(), stderr */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cbug</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>  </span><span class="code_comments">/* debug() */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>capi</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>

</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
    </span><span class="code_keywords">for</span><span> (</span><span class="code_types">int</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span></span><span class="code_numbers">3</span><span>; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
    {
        </span><span class="code_functions">fprintf</span><span>(</span><span class="code_constants">stderr</span><span>, </span><span class="code_strings">"- - - - -\n"</span><span>);
        </span><span class="code_functions">debug</span><span>();
        </span><span class="code_functions">debug</span><span>(</span><span class="code_strings">"I'm debugging..."</span><span>);
        </span><span class="code_functions">debug</span><span>(</span><span class="code_strings">"Value of i is: %d"</span><span>, i);
    }
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">- - - - -
000 File: 'main.c', line: 9, function: 'main'
001 File: 'main.c', line: 10, function: 'main'
    "I'm debugging..."
002 File: 'main.c', line: 11, function: 'main'
    "Value of i is: 0"
- - - - -
003 File: 'main.c', line: 9, function: 'main'
004 File: 'main.c', line: 10, function: 'main'
    "I'm debugging..."
005 File: 'main.c', line: 11, function: 'main'
    "Value of i is: 1"
- - - - -
006 File: 'main.c', line: 9, function: 'main'
007 File: 'main.c', line: 10, function: 'main'
    "I'm debugging..."
008 File: 'main.c', line: 11, function: 'main'
    "Value of i is: 2"</code></pre><br/><p class="info note"><span>Another great usecase of </span><code>debug</code><span> is to extend the functionality of the </span><a class="inline_link" href="cexc.html"><span></span><code>cexc</code><span></span></a><span> utility. While the handling mode is set to logging, so the exceptions are printed out to </span><code>stderr</code><span> for example, </span><code>debug</code><span> can print the exact file location. This can be seen in the next example
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>stdio</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>        </span><span class="code_comments">/* stderr */</span><span>
</span><span class="code_macros">#define</span><span> CEXC_LOG
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cexc</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>  </span><span class="code_comments">/* (start|stop)_exception_handling(), raise() */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cbug</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>  </span><span class="code_comments">/* debug() */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>capi</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>

</span><span class="code_types">void</span><span> </span><span class="code_functions">func</span><span>(</span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>ptr)
{
    </span><span class="code_keywords">if</span><span> (ptr </span><span class="code_operators">!</span><span></span><span class="code_operators">=</span><span> </span><span class="code_constants">NULL</span><span>)
        </span><span class="code_keywords">return</span><span>;
    </span><span class="code_functions">debug</span><span>();
</span><span class="code_macros">    #define</span><span> MSG </span><span class="code_strings">"Pointer is NULL"</span><span>
    </span><span class="code_functions">raise</span><span>(MSG, </span><span class="code_keywords">sizeof</span><span> MSG);
}

</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
    </span><span class="code_functions">start_exception_handling</span><span>(</span><span class="code_constants">stderr</span><span>);
    
    </span><span class="code_functions">func</span><span>(</span><span class="code_constants">NULL</span><span>);
    
    </span><span class="code_functions">stop_exception_handling</span><span>();
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">000 File: 'main.c', line: 10, function: 'func'
EXCEPTION: Pointer is NULL</code></pre><br/></div><div class="entity" id="func_boolean"><p><span class="name">boolean</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type"></span><span class="space_arg_type_name"> </span><span class="arg_name">value</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span>string (</span><code>char *</code><span>) representation of truth-test of the passed value</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Examples:</p><p class="info note"><span>Testing </span><code>0</code><span> and </span><code>1</code><span>:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"%s\n"</span><span>, </span><span class="code_functions">boolean</span><span>(</span><span class="code_numbers">0</span><span>));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"%s\n"</span><span>, </span><span class="code_functions">boolean</span><span>(</span><span class="code_numbers">1</span><span>));
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">false
true</code></pre><br/></div></div></div></div></body></html>