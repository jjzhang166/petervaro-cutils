<html><!-- www.cutils.org | Peter Varo | 2014 --><head><link href="http://www.cutils.org/favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="http://www.cutils.org/favicon.ico" rel="icon" type="image/x-icon"/><title>CBUG Debugging &amp; Logging</title><meta charset="utf-8"/><link href="css/cdoc.css" rel="stylesheet" type="text/css"/></head><body><div id="column1"><div id="generic"><img src="img/cutils.svg"/><br/><br/><h2><span>MODERN AND LIGHTWEIGHT C UTILITIES</span></h2><p><span>&mdash;</span></p><p><span>DESIGNED BY</span></p><p><span>PETER VARO &copy;2014</span></p><p><span>&mdash;</span></p><br/></div><div id="sidebar"><div><p class="label">Modules:</p></div><br/><a class="toc" href="index.html">CUTILS</a><a class="toc" href="c11.html">C11 Syntax Highlighter</a><a class="toc" href="carg.html">CARG Variadic Argument Macro</a><a class="toc toc_current" href="#">CBUG Debugging &amp; Logging</a><a class="toc" href="ccom.html">CCOM Comment Scanner and List Generator</a><a class="toc" href="cdar.html">CDAR Dynamic Array</a><a class="toc" href="cdep.html">CDEP Dependeny Graph</a><a class="toc" href="cdls.html">CDLS Double Linked List</a><a class="toc" href="cdoc.html">CDOC Documenting Tool</a><a class="toc" href="clic.html">CLIC License Comment Generator</a><a class="toc" href="cpro.html">CPRO Profiling</a><a class="toc" href="cres.html">CRES External Resources Packer</a><a class="toc" href="csls.html">CSLS Single Linked List</a><a class="toc" href="cutt.html">CUTT Unit Testing Tools</a><br/><div><p class="label">Options:</p><br/><a class="toc" href="#user_Name_Mangling">Name Mangling</a></div><br/><div><p class="label">Functions:</p><br/><a class="toc" href="#function_debug">debug()</a></div></div></div><div id="column2"><div id="content"><h1><span>CBUG | Debugging and Logging</span></h1><br/><p><span>A very lightweight debugging/logging single header-only utility,
contains a single function-like macro which can print its
invocation place, a custom message or a formatted message with
values to the standard error output.
</span></p><br/><div><h2 class="title">Options</h2><div class="entity" id="user_Name_Mangling"><p class="name">Name Mangling</p><br/><p class="info"><span>However </span><code>cutils</code><span> uses very short and expressive function names which
are not confronting with any of the standard library's entities,
sometimes one wants to use some of these function, macro or type
names in one's own project for other purposes. To solve this problem
</span><code>cutils</code><span> provides a macro variable, a flag, to turn on or off the
prefixes of the variable names. By default it is turned off.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Each public function or function-like macro, or type name will have the same </span><code>cutils_</code><span> prefix, as follows
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_functions">debug</span><span>();  </span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">&gt;</span><span>  </span><span class="code_functions">cutils_debug</span><span>();
</span></code></pre><br/><p class="info note"><span>One can compile all files or just some of it, defining the variable through the </span><code>-D</code><span> flag of the compiler, like this
:</span></p><br/><pre class="info"><code class="snippet">cc -std=c11 -Wall -DCUTILS_NAMESPACE -c -o filename.o</code></pre><br/><p class="info note"><span>Or one can define this variable before the inclusion of a header file:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#define</span><span> CUTILS_NAMESPACE
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cbug</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#undef</span><span> CUTILS_NAMESPACE</span></code></pre><br/></div><div><h2 class="title">Functions</h2><div class="entity" id="function_debug"><p><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">void</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span><br/><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">char *</span><span class="space_arg_type_name"> </span><span class="arg_name">message</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">char *</span><span class="space_arg_type_name"> </span><span class="arg_name">format_string</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type"></span><span class="space_arg_type_name"> </span><span class="arg_name">...</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>debug</code><span> has its own internal counter, which is scope based. (This
means, that each invocaition place's scope has its own counter.)
This counter increases each time when the function-like macro is
called. </span><code>debug</code><span> prints the value of the counter and the location
informations from where it was called.
</span><br/><span></span><br/><span>
</span><code>debug</code><span> can be called with a single argument, which has to be a
</span><code>char *</code><span> string. This message will be indented and printed out after
the default debugging line.
</span><br/><span></span><br/><span>
</span><code>debug</code><span> also can be called with 2+ arguments (up to 63 in total). In
this case the first argument has to be a format-string and all the
other arguments can be any type specified in the format-string. It
works exactly as the standard library's </span><code>printf</code><span> function. The
formatted message will be indented and printed out after the default
debugging line.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Examples:</p><p class="info note"><span>Calling </span><code>debug</code><span> in all 3 forms from the main function:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>stdio</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>        </span><span class="code_comments">/* fprintf(), stderr */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cbug</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>  </span><span class="code_comments">/* debug() */</span><span>

</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
    </span><span class="code_keywords">for</span><span> (</span><span class="code_types">int</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span></span><span class="code_numbers">3</span><span>; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
    {
        </span><span class="code_functions">fprintf</span><span>(</span><span class="code_constants">stderr</span><span>, </span><span class="code_strings">"- - - - -\n"</span><span>);
        </span><span class="code_functions">debug</span><span>();
        </span><span class="code_functions">debug</span><span>(</span><span class="code_strings">"I'm debugging..."</span><span>);
        </span><span class="code_functions">debug</span><span>(</span><span class="code_strings">"Value of i is: %d"</span><span>, i);
    }
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">- - - - -
000 File: 'main.c', line: 9, function: 'main'
001 File: 'main.c', line: 10, function: 'main'
    "I'm debugging..."
002 File: 'main.c', line: 11, function: 'main'
    "Value of i is: 0"
- - - - -
003 File: 'main.c', line: 9, function: 'main'
004 File: 'main.c', line: 10, function: 'main'
    "I'm debugging..."
005 File: 'main.c', line: 11, function: 'main'
    "Value of i is: 1"
- - - - -
006 File: 'main.c', line: 9, function: 'main'
007 File: 'main.c', line: 10, function: 'main'
    "I'm debugging..."
008 File: 'main.c', line: 11, function: 'main'
    "Value of i is: 2"</code></pre><br/></div></div></div></div></body></html>