<html><!-- www.cutils.org | Peter Varo | 2014 --><head><link href="http://www.cutils.org/favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="http://www.cutils.org/favicon.ico" rel="icon" type="image/x-icon"/><title>CBUG Debugging &amp; Logging</title><meta charset="utf-8"/><link href="css/cdoc.css" rel="stylesheet" type="text/css"/></head><body><div id="column1"><div id="generic"><img src="img/cutils.svg"/><br/><h2><span>MODERN AND LIGHTWEIGHT C UTILITIES</span></h2><p><span>&mdash;</span></p><p><span>DESIGNED BY</span></p><p><span>PETER VARO &copy;2014</span></p><p><span>&mdash;</span></p><br/></div><div id="sidebar"><div><p class="label">Modules:</p></div><br/><a class="toc" href="index.html">CUTILS</a><a class="toc" href="c11.html">C11 Syntax Highlighter</a><a class="toc" href="cref.html">CREF Quick Reference</a><a class="toc" href="cenv.html">CENV Environment Generator</a><a class="toc" href="cdep.html">CDEP Dependeny Graph</a><a class="toc" href="ccom.html">CCOM Comment Scanner</a><a class="toc" href="cver.html">CVER Versioning</a><a class="toc" href="clic.html">CLIC License Comment Generator</a><a class="toc" href="cres.html">CRES External Resources Packer</a><a class="toc" href="carg.html">CARG Variadic Argument Macro</a><a class="toc toc_current" href="#">CBUG Debugging &amp; Logging</a><a class="toc" href="cexc.html">CEXC Exception Handling</a><a class="toc" href="cpro.html">CPRO Profiling</a><a class="toc" href="cutt.html">CUTT Unit Testing Tools</a><a class="toc" href="cdar.html">CDAR Dynamic Array</a><a class="toc" href="cstr.html">CSTR Strings</a><a class="toc" href="csll.html">CSLL Single Linked List</a><a class="toc" href="cdll.html">CDLL Double Linked List</a><a class="toc" href="cmap.html">CMAP HashMap</a><a class="toc" href="cfps.html">CFPS Frame Per Second</a><a class="toc" href="ccol.html">CCOL Color Helper</a><a class="toc" href="cdoc.html">CDOC Documenting Tool</a><br/><div><p class="label">Options:</p><br/><a class="toc" href="#user_Name_Mangling">Name Mangling</a></div><br/><div><p class="label">Flags:</p><br/><a class="toc" href="#user_CBUG_OFF">CBUG_OFF</a></div><br/><div><p class="label">Functions:</p><br/><a class="toc" href="#func_debug">debug()</a></div></div></div><div id="column2"><div id="content"><h1><span>CBUG | Debugging and Logging</span></h1><br/><p><span>A very lightweight debugging/logging single header-only utility,
contains a single function-like macro which can print its
invocation place, a custom message or a formatted message with
values to the standard error output.
</span></p><br/><div><h2 class="title">Options</h2><div class="entity" id="user_Name_Mangling"><p class="name">Name Mangling</p><br/><p class="info"><span>However </span><code>cutils</code><span> uses very short and expressive function names which
are not confronting with any of the standard library's entities,
sometimes one wants to use some of these function, macro or type
names in one's own project for other purposes. To solve this problem
</span><code>cutils</code><span> provides a macro variable, a flag, to turn on or off the
prefixes of the variable names. By default it is turned off.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Each public function or function-like macro, or type name will have the same </span><code>cutils_</code><span> prefix, as follows
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_functions">debug</span><span>();  </span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">&gt;</span><span>  </span><span class="code_functions">cutils_debug</span><span>();
</span></code></pre><br/><p class="info note"><span>One can compile all files or just some of it, defining the variable through the </span><code>-D</code><span> flag of the compiler, like this
:</span></p><br/><pre class="info"><code class="snippet">cc -std=c11 -Wall -DCUTILS_NAMESPACE -c -o filename.o</code></pre><br/><p class="info note"><span>Or one can define this variable before the inclusion of a header file:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#define</span><span> CUTILS_NAMESPACE
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cbug</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#undef</span><span> CUTILS_NAMESPACE</span></code></pre><br/></div><div><h2 class="title">Flags</h2><div class="entity" id="user_CBUG_OFF"><p class="name">CBUG_OFF</p><br/><p class="info"><span>The </span><code>debug</code><span> macro can be turned off by defining an empty </span><code>CBUG_OFF</code><span>
macro variable before the include macro statement or by compiling
the the code with a </span><code>-DCBUG_OFF</code><span> flag. If this variable is defined
all the apperences of the </span><code>debug</code><span> macro will be removed from the
source file.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Defining variable before inclusion:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#define</span><span> CBUG_OFF
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cbug</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#undef</span><span> CBUG_OFF
</span></code></pre><br/></div><div><h2 class="title">Functions</h2><div class="entity" id="func_debug"><p><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">void</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span><br/><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">char *</span><span class="space_arg_type_name"> </span><span class="arg_name">message</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">String</span><span class="space_arg_type_name"> </span><span class="arg_name">message</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">debug</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">char *</span><span class="space_arg_type_name"> </span><span class="arg_name">format_string</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type"></span><span class="space_arg_type_name"> </span><span class="arg_name">...</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>debug</code><span> has its own internal counter, which is scope based. (This
means, that each invocaition place's scope has its own counter.)
This counter increases each time when the function-like macro is
called. </span><code>debug</code><span> prints the value of the counter and the location
informations from where it was called.
</span><br/><span></span><br/><span>
</span><code>debug</code><span> can be called with a single argument, which has to be a
</span><code>char *</code><span> string. This message will be indented and printed out after
the default debugging line.
</span><br/><span></span><br/><span>
</span><code>debug</code><span> also can be called with 2+ arguments (up to 63 in total). In
this case the first argument has to be a format-string and all the
other arguments can be any type specified in the format-string. It
works exactly as the standard library's </span><code>printf</code><span> function. The
formatted message will be indented and printed out after the default
debugging line.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/></div></div></div></div></body></html>