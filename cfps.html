<html><!-- www.cutils.org | Peter Varo | 2014 --><head><link href="http://www.cutils.org/favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="http://www.cutils.org/favicon.ico" rel="icon" type="image/x-icon"/><title>CFPS Frame Per Second</title><meta charset="utf-8"/><link href="css/cdoc.css" rel="stylesheet" type="text/css"/></head><body><div id="column1"><div id="generic"><img src="img/cutils.svg"/><br/><h2><span>MODERN AND LIGHTWEIGHT C UTILITIES</span></h2><p><span>&mdash;</span></p><p><span>DESIGNED BY</span></p><p><span>PETER VARO &copy;2014</span></p><p><span>&mdash;</span></p><br/></div><div id="sidebar"><div><p class="label">Modules:</p></div><br/><a class="toc" href="index.html">CUTILS</a><a class="toc" href="c11.html">C11 Syntax Highlighter</a><a class="toc" href="cref.html">CREF Quick Reference</a><a class="toc" href="cenv.html">CENV Environment Generator</a><a class="toc" href="cdep.html">CDEP Dependeny Graph</a><a class="toc" href="ccom.html">CCOM Comment Scanner</a><a class="toc" href="cver.html">CVER Versioning</a><a class="toc" href="clic.html">CLIC License Comment Generator</a><a class="toc" href="cres.html">CRES External Resources Packer</a><a class="toc" href="capi.html">CAPI Interface</a><a class="toc" href="carg.html">CARG Variadic Argument Macro</a><a class="toc" href="cbug.html">CBUG Debugging &amp; Logging</a><a class="toc" href="cexc.html">CEXC Exception Handling</a><a class="toc" href="cpro.html">CPRO Profiling</a><a class="toc" href="cutt.html">CUTT Unit Testing Tools</a><a class="toc" href="cdar.html">CDAR Dynamic Array</a><a class="toc" href="cstr.html">CSTR Strings</a><a class="toc" href="csll.html">CSLL Single Linked List</a><a class="toc" href="cdll.html">CDLL Double Linked List</a><a class="toc" href="cmap.html">CMAP HashMap</a><a class="toc toc_current" href="#">CFPS Frame Per Second</a><a class="toc" href="ccol.html">CCOL Color Helper</a><a class="toc" href="cdoc.html">CDOC Documenting Tool</a><a class="toc" href="call.html">CALL Include All</a><br/><div><p class="label">Options:</p><br/><a class="toc" href="#user_Name_Mangling">Name Mangling</a></div><br/><div><p class="label">Functions:</p><br/><a class="toc" href="#func_printfps">printfps()</a><a class="toc" href="#func_getfps">getfps()</a></div></div></div><div id="column2"><div id="content"><h1><span>CFPS | Frame Per Second</span></h1><br/><p><span>A single header-only frame per second counter. It implements an
inline functions and a macro wrapper around that.
</span></p><br/><div><h2 class="title">Options</h2><div class="entity" id="user_Name_Mangling"><p class="name">Name Mangling</p><br/><p class="info"><span>However </span><code>cutils</code><span> uses very short and expressive function names which
are not confronting with any of the standard library's entities,
sometimes one wants to use some of these function, macro or type
names in one's own project for other purposes. To solve this problem
</span><code>cutils</code><span> provides a macro variable, a flag, to turn on or off the
prefixes of the variable names. By default it is turned off.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Each public function or function-like macro, or type name will have the same </span><code>cutils_</code><span> prefix, as follows
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_functions">printfps</span><span>();  </span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">&gt;</span><span>  </span><span class="code_functions">cutils_printfps</span><span>();
</span></code></pre><br/><p class="info note"><span>One can compile all files or just some of it, defining the variable through the </span><code>-D</code><span> flag of the compiler, like this
:</span></p><br/><pre class="info"><code class="snippet">cc -std=c11 -Wall -DCUTILS_NAMESPACE -c -o filename.o</code></pre><br/><p class="info note"><span>Or one can define this variable before the inclusion of the API header file
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cfps</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#define</span><span> CUTILS_NAMESPACE
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>capi</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span></code></pre><br/></div><div><h2 class="title">Functions</h2><div class="entity" id="func_printfps"><p><span class="name">printfps</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">double(*</span><span class="space_arg_type_name"> </span><span class="arg_name">timer_func</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(void)</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>printfps</code><span> is a function-like macro, which wraps the
</span><a class="inline_link" href="#func_getfps"><span></span><code>getfps</code><span></span></a><span> function. It requires a timer function
</span><code>timer_func</code><span> as it's only argument which has to return a </span><code>double</code><span>
value. It prints the frame per second value to the standard </span><code>stdout</code><span>
stream.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Examples:</p><p class="info note"><span>The next example prints the fps to the </span><code>stdout</code><span>:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>GLFW</span><span class="code_operators">/</span><span>glfw</span><span class="code_numbers">3</span><span></span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>   </span><span class="code_comments">/* glfw...(), GLFW... */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cfps</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>  </span><span class="code_comments">/* printfps() */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>capi</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>

</span><span class="code_comments">/* ... GLFW setup */</span><span>

</span><span class="code_functions">glfwSwapInterval</span><span>(</span><span class="code_numbers">0</span><span>);
</span><span class="code_types">void</span><span> </span><span class="code_functions">run</span><span>(GLFWwindow </span><span class="code_operators">*</span><span>window)
{
    </span><span class="code_keywords">while</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">glfwWindowShouldClouse</span><span>(window))
    {
        </span><span class="code_comments">/* ... Draw something */</span><span>
        
        </span><span class="code_functions">glfwSwapBuffers</span><span>(window);
        </span><span class="code_functions">glfwPollEvents</span><span>();
        
        </span><span class="code_functions">printfps</span><span>(glfwGetTime);
    }
}
</span></code></pre><br/></div><div class="entity" id="func_getfps"><p><span class="name">getfps</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">double(*</span><span class="space_arg_type_name"> </span><span class="arg_name">timer_func</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(void)</span><span class="space_arg_type_name"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">void(*</span><span class="space_arg_type_name"> </span><span class="arg_name">handler_func</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(int,void*)</span><span class="space_arg_type_name"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">void *</span><span class="space_arg_type_name"> </span><span class="arg_name">data</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span>It is a more general purpose fps function. It also requires a timer
function which returns a double value, but it also requires a handler
function, which will be called on every second; and a pointer to any
kind of data, which will be passed to the handler function, to deal
with it.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Examples:</p><p class="info note"><span>The next example shows how to use </span><code>getfps</code><span> with GLFW to set the title of the window to show the actual frame per second value
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>stdio</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>        </span><span class="code_comments">/* snprintf() */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>GLFW</span><span class="code_operators">/</span><span>glfw</span><span class="code_numbers">3</span><span></span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>   </span><span class="code_comments">/* glfw...(), GLFW... */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>cfps</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>  </span><span class="code_comments">/* getfps() */</span><span>
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>capi</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>

</span><span class="code_keywords">static</span><span> </span><span class="code_types">void</span><span> </span><span class="code_functions">fps_title_setter</span><span>(</span><span class="code_types">int</span><span> fps, </span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>data)
{
    </span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>array </span><span class="code_operators">=</span><span> (</span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>)data;
    </span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>buffer </span><span class="code_operators">=</span><span> (</span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>)(array[</span><span class="code_numbers">1</span><span>]);
    </span><span class="code_functions">snprintf</span><span>(buffer, </span><span class="code_operators">*</span><span>((</span><span class="code_types">int</span><span> </span><span class="code_operators">*</span><span>)(array[</span><span class="code_numbers">2</span><span>])), </span><span class="code_strings">"[FPS: %d]"</span><span>, fps);
    </span><span class="code_functions">glfwSetWindowTitle</span><span>((GLFWwindow </span><span class="code_operators">*</span><span>)(array[</span><span class="code_numbers">0</span><span>]), buffer);
}

</span><span class="code_comments">/* ... GLFW setup */</span><span>

</span><span class="code_types">void</span><span> </span><span class="code_functions">run</span><span>(GLFWwindow </span><span class="code_operators">*</span><span>window)
{
    </span><span class="code_types">char</span><span> fps_title_txt[</span><span class="code_numbers">10</span><span>];
    </span><span class="code_types">int</span><span>  fps_title_len </span><span class="code_operators">=</span><span> </span><span class="code_numbers">10</span><span>;
    </span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>data[] </span><span class="code_operators">=</span><span> {window, fps_title_txt, </span><span class="code_operators">&amp;</span><span>fps_title_len};
    
    </span><span class="code_functions">glfwSwapInterval</span><span>(</span><span class="code_numbers">0</span><span>);
    </span><span class="code_keywords">while</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">glfwWindowShouldClose</span><span>(window))
    {
        </span><span class="code_comments">/* ... Draw something */</span><span>
        
        </span><span class="code_functions">glfwSwapBuffers</span><span>(window);
        </span><span class="code_functions">glfwPollEvents</span><span>();
        
        </span><span class="code_functions">getfps</span><span>(glfwGetTime, fps_title_setter, </span><span class="code_operators">&amp;</span><span>data);
    }
}
</span></code></pre><br/></div></div></div></div></body></html>