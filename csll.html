<html><!-- www.cutils.org | Peter Varo | 2014 --><head><link href="http://www.cutils.org/favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="http://www.cutils.org/favicon.ico" rel="icon" type="image/x-icon"/><title>CSLL Singly Linked List</title><meta charset="utf-8"/><link href="css/cdoc.css" rel="stylesheet" type="text/css"/></head><body><div id="column1"><div id="generic"><img src="img/cutils.svg"/><br/><h2><span>MODERN AND LIGHTWEIGHT C UTILITIES</span></h2><p><span>&mdash;</span></p><p><span>DESIGNED BY</span></p><p><span>PETER VARO &copy;2014</span></p><p><span>&mdash;</span></p><br/></div><div id="sidebar"><div><p class="label">Modules:</p></div><br/><a class="toc" href="index.html">CUTILS</a><a class="toc" href="c11.html">C11 Syntax Highlighter</a><a class="toc" href="cref.html">CREF Quick Reference</a><a class="toc" href="cenv.html">CENV Environment Generator</a><a class="toc" href="cdep.html">CDEP Dependeny Graph</a><a class="toc" href="ccom.html">CCOM Comment Scanner</a><a class="toc" href="cver.html">CVER Versioning</a><a class="toc" href="clic.html">CLIC License Comment Generator</a><a class="toc" href="cres.html">CRES External Resources Packer</a><a class="toc" href="capi.html">CAPI Interface</a><a class="toc" href="carg.html">CARG Variadic Argument Macro</a><a class="toc" href="cbug.html">CBUG Debugging &amp; Logging</a><a class="toc" href="cexc.html">CEXC Exception Handling</a><a class="toc" href="cpro.html">CPRO Profiling</a><a class="toc" href="cutt.html">CUTT Unit Testing Tools</a><a class="toc" href="cdar.html">CDAR Dynamic Array</a><a class="toc" href="cstr.html">CSTR Strings</a><a class="toc toc_current" href="#">CSLL Singly Linked List</a><a class="toc" href="cdll.html">CDLL Doubly Linked List</a><a class="toc" href="cmap.html">CMAP HashMap</a><a class="toc" href="cfps.html">CFPS Frame Per Second</a><a class="toc" href="ccol.html">CCOL Color Helper</a><a class="toc" href="cdoc.html">CDOC Documenting Tool</a><a class="toc" href="call.html">CALL Include All</a><br/><div><p class="label">Options:</p><br/><a class="toc" href="#user_Name_Mangling">Name Mangling</a></div><br/><div><p class="label">Types:</p><br/><a class="toc" href="#type_SinglyLinkedList_char">SinglyLinkedList_char</a><a class="toc" href="#type_SinglyLinkedList_signed_char">SinglyLinkedList_signed_char</a><a class="toc" href="#type_SinglyLinkedList_unsigned_char">SinglyLinkedList_unsigned_char</a><a class="toc" href="#type_SinglyLinkedList_char_ptr">SinglyLinkedList_char_ptr</a><a class="toc" href="#type_SinglyLinkedList_short">SinglyLinkedList_short</a><a class="toc" href="#type_SinglyLinkedList_unsigned_short">SinglyLinkedList_unsigned_short</a><a class="toc" href="#type_SinglyLinkedList_int">SinglyLinkedList_int</a><a class="toc" href="#type_SinglyLinkedList_unsigned_int">SinglyLinkedList_unsigned_int</a><a class="toc" href="#type_SinglyLinkedList_long">SinglyLinkedList_long</a><a class="toc" href="#type_SinglyLinkedList_unsigned_long">SinglyLinkedList_unsigned_long</a><a class="toc" href="#type_SinglyLinkedList_long_long">SinglyLinkedList_long_long</a><a class="toc" href="#type_SinglyLinkedList_unsigned_long_long">SinglyLinkedList_unsigned_long_long</a><a class="toc" href="#type_SinglyLinkedList_float">SinglyLinkedList_float</a><a class="toc" href="#type_SinglyLinkedList_double">SinglyLinkedList_double</a><a class="toc" href="#type_SinglyLinkedList_long_double">SinglyLinkedList_long_double</a><a class="toc" href="#type_SinglyLinkedList_bool">SinglyLinkedList_bool</a><a class="toc" href="#type_SinglyLinkedList_size_t">SinglyLinkedList_size_t</a><a class="toc" href="#type_SinglyLinkedList_ptrdiff_t">SinglyLinkedList_ptrdiff_t</a><a class="toc" href="#type_SinglyLinkedList_void_ptr">SinglyLinkedList_void_ptr</a></div><br/><div><p class="label">Functions:</p><br/><a class="toc" href="#func_new">new()</a><a class="toc" href="#func_del">del()</a><a class="toc" href="#func_print">print()</a><a class="toc" href="#func_len">len()</a><a class="toc" href="#func_clear">clear()</a><a class="toc" href="#func_iter">iter()</a><a class="toc" href="#func_next">next()</a><a class="toc" href="#func_swap">swap()</a><a class="toc" href="#func_reverse">reverse()</a><a class="toc" href="#func_append">append()</a><a class="toc" href="#func_push">push()</a><a class="toc" href="#func_pull">pull()</a><a class="toc" href="#func_pop">pop()</a><a class="toc" href="#func_sub">sub()</a><a class="toc" href="#func_truncate">truncate()</a><a class="toc" href="#func_set">set()</a><a class="toc" href="#func_get">get()</a><a class="toc" href="#func_map">map()</a></div></div></div><div id="column2"><div id="content"><h1><span>CSLL | Singly Linked List</span></h1><br/><p><span>Implementation of singly linked list and its iterator high-level
data-type objects and their methods.
</span></p><br/><div><h2 class="title">Options</h2><div class="entity" id="user_Name_Mangling"><p class="name">Name Mangling</p><br/><p class="info"><span>However </span><code>cutils</code><span> uses very short and expressive function names which
are not confronting with any of the standard library's entities,
sometimes one wants to use some of these function, macro or type
names in one's own project for other purposes. To solve this problem
</span><code>cutils</code><span> provides a macro variable, a flag, to turn on or off the
prefixes of the variable names. By default it is turned off.
</span></p><br/></div><p class="info label">Examples:</p><p class="info note"><span>Each public function or function-like macro, or type name will have the same </span><code>cutils_</code><span> prefix, as follows
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_functions">iter</span><span>();  </span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">=</span><span></span><span class="code_operators">&gt;</span><span>  </span><span class="code_functions">cutils_iter</span><span>();
</span></code></pre><br/><p class="info note"><span>One can compile all files or just some of it, defining the variable through the </span><code>-D</code><span> flag of the compiler, like this
:</span></p><br/><pre class="info"><code class="snippet">cc -std=c11 -Wall -DCUTILS_NAMESPACE -c -o filename.o</code></pre><br/><p class="info note"><span>Or one can define this variable before the inclusion of the API header file
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>csll</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span><span class="code_macros">#define</span><span> CUTILS_NAMESPACE
</span><span class="code_macros">#include</span><span> </span><span class="code_operators">&lt;</span><span>cutils</span><span class="code_operators">/</span><span>capi</span><span class="code_operators">.</span><span>h</span><span class="code_operators">&gt;</span><span>
</span></code></pre><br/></div><div><h2 class="title">Types</h2><div class="entity" id="type_SinglyLinkedList_char"><span class="name">SinglyLinkedList_char</span><span class="arg_paren"> &lt; </span><span class="arg_type">char</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_signed_char"><span class="name">SinglyLinkedList_signed_char</span><span class="arg_paren"> &lt; </span><span class="arg_type">signed char</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_unsigned_char"><span class="name">SinglyLinkedList_unsigned_char</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned char</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_char_ptr"><span class="name">SinglyLinkedList_char_ptr</span><span class="arg_paren"> &lt; </span><span class="arg_type">char *</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_short"><span class="name">SinglyLinkedList_short</span><span class="arg_paren"> &lt; </span><span class="arg_type">short</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_unsigned_short"><span class="name">SinglyLinkedList_unsigned_short</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned short</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_int"><span class="name">SinglyLinkedList_int</span><span class="arg_paren"> &lt; </span><span class="arg_type">int</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_unsigned_int"><span class="name">SinglyLinkedList_unsigned_int</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned int</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_long"><span class="name">SinglyLinkedList_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">long</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_unsigned_long"><span class="name">SinglyLinkedList_unsigned_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned long</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_long_long"><span class="name">SinglyLinkedList_long_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">long long</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_unsigned_long_long"><span class="name">SinglyLinkedList_unsigned_long_long</span><span class="arg_paren"> &lt; </span><span class="arg_type">unsigned long long</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_float"><span class="name">SinglyLinkedList_float</span><span class="arg_paren"> &lt; </span><span class="arg_type">float</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_double"><span class="name">SinglyLinkedList_double</span><span class="arg_paren"> &lt; </span><span class="arg_type">double</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_long_double"><span class="name">SinglyLinkedList_long_double</span><span class="arg_paren"> &lt; </span><span class="arg_type">long double</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_bool"><span class="name">SinglyLinkedList_bool</span><span class="arg_paren"> &lt; </span><span class="arg_type">bool</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_size_t"><span class="name">SinglyLinkedList_size_t</span><span class="arg_paren"> &lt; </span><span class="arg_type">size_t</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_ptrdiff_t"><span class="name">SinglyLinkedList_ptrdiff_t</span><span class="arg_paren"> &lt; </span><span class="arg_type">ptrdiff_t</span><span class="arg_paren"> &gt;</span><br/></div><div class="entity" id="type_SinglyLinkedList_void_ptr"><span class="name">SinglyLinkedList_void_ptr</span><span class="arg_paren"> &lt; </span><span class="arg_type">void *</span><span class="arg_paren"> &gt;</span><br/><p class="info"><span>This is the so-called universal list type, and also the base type of
all the specific typed </span><code>SinglyLinkedList</code><span>s. It holds </span><code>void *</code><span> type of
items, therefore it can hold any kind of pointer to type. It has a
slightly different </span><a class="inline_link" href="#func_new"><span>new</span></a><span> function as well.
</span><br/><span></span><br/><span>
</span><code>SinglyLinkedList</code><span> stores the items by their values (copies them), not
only by a pointer to them. For example if the list is a
</span><a class="inline_link" href="#type_SinglyLinkedList_int"><span></span><code>SinglyLinkedList_int</code><span></span></a><span> it will save a
copy of the integers themselves inside itself. Also, if for example
the list is a
</span><a class="inline_link" href="#type_SinglyLinkedList_void_ptr"><span></span><code>SinglyLinkedList_void_ptr</code><span></span></a><span> all the
pointers will be copied and stored and pointing at the exact same
memory location as the original pointers.
</span></p><br/></div></div><div><h2 class="title">Functions</h2><div class="entity" id="func_new"><p><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type **</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type **</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_void_ptr **</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_size</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">new</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_void_ptr **</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_size</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>new</code><span> is a type-generic function-like macro, which takes a pointer to
pointer to a type-specific SinglyLinkedList to create a new list. All
types of SinglyLinkedList can be initialised as an empty list by passing
only the pointer to pointer to the SinglyLinkedList to the </span><code>new</code><span> method;
except the </span><code>SinglyLinkedList_void_ptr</code><span> which also requires the size of the
type of the data it is storing.
</span><br/><span></span><br/><span>
Also: all types of SinglyLinkedList can be initialised by arbitrary
number of data, by passing the number of items, and the pointer to the
data to the </span><code>new</code><span> method; except the </span><code>SinglyLinkedList_void_ptr</code><span> which
also needs the size of the type of the data it is storing.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if list was created successfully</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if internal allocation failed</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">internal allocation failed</code><p class="exception_note"><span>The allocation of space in memory for the instance of the base struct and/or for the raw $type$ of the data failed</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Create a new empty list of </span><code>int</code><span>s and another of </span><code>void*</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* SinglyLinkedList of integers */</span><span>
SinglyLinkedList_int </span><span class="code_operators">*</span><span>linlist_i;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist_i, </span><span class="code_numbers">0</span><span>, </span><span class="code_constants">NULL</span><span>);

</span><span class="code_comments">/* SinglyLinkedList of pointers to void */</span><span>
</span><span class="code_keywords">typedef</span><span> </span><span class="code_keywords">struct</span><span> {</span><span class="code_types">int</span><span> i; </span><span class="code_types">float</span><span> f;} Item;
SinglyLinkedList_void_ptr </span><span class="code_operators">*</span><span>linlist_vp;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist_vp, </span><span class="code_keywords">sizeof</span><span>(Item</span><span class="code_operators">*</span><span>), </span><span class="code_numbers">0</span><span>, </span><span class="code_constants">NULL</span><span>);
</span></code></pre><br/><p class="info note"><span>a shorthand version of the above can also be used:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* SinglyLinkedList of integers */</span><span>
SinglyLinkedList_int </span><span class="code_operators">*</span><span>linlist_i;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist_i);

</span><span class="code_comments">/* SinglyLinkedList of pointers to void */</span><span>
</span><span class="code_keywords">typedef</span><span> </span><span class="code_keywords">struct</span><span> {</span><span class="code_types">int</span><span> i; </span><span class="code_types">float</span><span> f;} Item;
SinglyLinkedList_void_ptr </span><span class="code_operators">*</span><span>linlist_vp;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist_vp, </span><span class="code_keywords">sizeof</span><span>(Item</span><span class="code_operators">*</span><span>));
</span></code></pre><br/><p class="info note"><span>Create a new SinglyLinkedList of </span><code>double</code><span>s filled with a single </span><code>double</code><span>:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_types">double</span><span> number </span><span class="code_operators">=</span><span> </span><span class="code_numbers">.1234</span><span>;
SinglyLinkedList_double </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">1</span><span>, </span><span class="code_operators">&amp;</span><span>number);
</span></code></pre><br/><p class="info note"><span>Create a new SinglyLinkedList of </span><code>float</code><span>s filled with 4 </span><code>float</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_types">float</span><span> numbers[] </span><span class="code_operators">=</span><span> {</span><span class="code_numbers">1.f</span><span>, </span><span class="code_numbers">2.f</span><span>, </span><span class="code_numbers">3.f</span><span>, </span><span class="code_numbers">4.f</span><span>};
SinglyLinkedList_float </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">4</span><span>, </span><span class="code_operators">&amp;</span><span>numbers);
</span></code></pre><br/><p class="info note"><span>Don't forget to check if the creation of the SinglyLinkedList was successful:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_macros">#define</span><span> CHARS </span><span class="code_strings">"dennis ritchie"</span><span>
SinglyLinkedList_char </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, (</span><span class="code_keywords">sizeof</span><span> CHARS) </span><span class="code_operators">-</span><span> </span><span class="code_numbers">1</span><span>, CHARS))
{
    </span><span class="code_functions">fprintf</span><span>(</span><span class="code_constants">stderr</span><span>, </span><span class="code_strings">"Internal allocation failed\n"</span><span>);
}
</span></code></pre><br/></div><div class="entity" id="func_del"><p><span class="name">del</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>del</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList and deletes the object and all of its content.</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/></div><div class="entity" id="func_print"><p><span class="name">print</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">print</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">char*(*</span><span class="space_arg_type_name"> </span><span class="arg_name">formatter</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(const type*, char**, size_t*)</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>print</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific SinglyLinkedList and prints its content formatted.
Internally it is using the format string notation of the standard
library, and all the basic C and </span><code>cutils</code><span> types prints out with the
proper formatting. It is also extended with some user-friendly
representation, like the </span><code>bool</code><span> values, the </span><code>char</code><span> and </span><code>char*</code><span>s or the
generic </span><code>void*</code><span>s.
</span><br/><span></span><br/><span>
It is also possible to pass a custom formatter as the second argument,
which makes it possible to format user-defined types. This </span><code>formatter</code><span>
callback function takes a pointer to type, a pointer to pointer to
</span><code>char</code><span> which points to a dynamically allocated buffer and a pointer
to a </span><code>size_t</code><span> which is the size of the allcoated buffer (which size is
128 </span><code>char</code><span>s by default). The </span><code>formatter</code><span> function can resize this
buffer (and it will be resized until the print function returns) or it
can change the pointer to point to other values. (For example, if the
object contains pointers to </span><code>char</code><span>s, it would be unefficient to copy
the string of each value.) For each item the passed pointer will
always point to the default buffer, even the pointer was changed for
the previous item.
</span><br/><span></span><br/><span>
</span><b><i><span>Note 1:</span></i></b><span> Do not </span><code>free()</code><span> the buffer, it will be automatically
</span><code>free</code><span>'d at the end of the </span><code>print</code><span> funtion. If the buffer is </span><code>free</code><span>'d
before the </span><code>print</code><span> function printed all the content of the object, it
is very likely that the program will crash with a </span><code>SEGMENTATION FAULT</code><span>.
</span><br/><span></span><br/><span>
</span><b><i><span>Note 2:</span></i></b><span> If </span><code>print</code><span> is used on a </span><code>SinglyLinkedList_char_ptr</code><span>, all
</span><code>char*</code><span>s need to be null-terminated, otherwise the function call
will produce undefined-behaviour. It is highly recommended, to use
the </span><a class="inline_link" href="cstr.html"><span></span><code>String</code><span></span></a><span> object in case of literal purposes.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">internal allocation failed</code><p class="exception_note"><span>The allocation of space in memory for the instance of the base struct and/or for the raw $type$ of the data failed</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Different types of SinglyLinkedLists have different representations:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* SinglyLinkedList of pointers to bools */</span><span>
SinglyLinkedList_bool </span><span class="code_operators">*</span><span>linlist_b;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist_b, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">bool</span><span>[]){</span><span class="code_constants">true</span><span>, </span><span class="code_constants">false</span><span>, </span><span class="code_constants">false</span><span>, </span><span class="code_constants">true</span><span>, </span><span class="code_constants">true</span><span>})))
    </span><span class="code_functions">print</span><span>(linlist_b);

</span><span class="code_comments">/* SinglyLinkedList of pointers to doubles */</span><span>
SinglyLinkedList_double </span><span class="code_operators">*</span><span>linlist_d;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist_d, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">double</span><span>[]){</span><span class="code_numbers">2.5</span><span>, </span><span class="code_numbers">17.257</span><span>, </span><span class="code_numbers">65.537</span><span>, </span><span class="code_numbers">42.9496</span><span>})))
    </span><span class="code_functions">print</span><span>(linlist_d);

</span><span class="code_comments">/* SinglyLinkedList of pointers to chars */</span><span>
SinglyLinkedList_char </span><span class="code_operators">*</span><span>linlist_c;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist_c, </span><span class="code_numbers">6</span><span>, ((</span><span class="code_types">char</span><span>[]){'\n', '\t', '\\', </span><span class="code_strings">'\'</span><span>', '\</span><span class="code_numbers">0</span><span>', </span><span class="code_strings">'"'</span><span>})))
    </span><span class="code_functions">print</span><span>(linlist_c);

</span><span class="code_comments">/* SinglyLinkedList of pointers to pointer to char */</span><span>
SinglyLinkedList_char_ptr </span><span class="code_operators">*</span><span>linlist_cp;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist_cp, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">char</span><span></span><span class="code_operators">*</span><span>[]){</span><span class="code_strings">"Talk is cheap.\nShow me the code.\n"</span><span>
                                   </span><span class="code_strings">"\t--\tLinus Torvalds\a"</span><span>})));
    </span><span class="code_functions">print</span><span>(linlist_cp);

</span><span class="code_comments">/* SinglyLinkedList of pointers to pointer to void */</span><span>
SinglyLinkedList_void_ptr </span><span class="code_operators">*</span><span>linlist_vp;
</span><span class="code_keywords">if</span><span> (</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist_vp, </span><span class="code_keywords">sizeof</span><span>(</span><span class="code_types">int</span><span> </span><span class="code_operators">*</span><span>), </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">void</span><span></span><span class="code_operators">*</span><span>[]){</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">int</span><span>){</span><span class="code_numbers">55</span><span>},
                                                  </span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">int</span><span>){</span><span class="code_numbers">77</span><span>},
                                                  </span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">int</span><span>){</span><span class="code_numbers">99</span><span>}})))
    </span><span class="code_functions">print</span><span>(linlist_vp);

</span><span class="code_functions">del</span><span>(linlist_b);
</span><span class="code_functions">del</span><span>(linlist_d);
</span><span class="code_functions">del</span><span>(linlist_c);
</span><span class="code_functions">del</span><span>(linlist_cp);
</span><span class="code_functions">del</span><span>(linlist_vp);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_bool{true, false, false, true, true}
SinglyLinkedList_double{2.500000, 17.257000, 65.537000, 42.949600}
SinglyLinkedList_char{'\n', '\t', '\\', '\'', '\0', '"'}
SinglyLinkedList_char_ptr{"Talk is cheap.\nShow me the code.\n", "\t--\tLinus Torvalds\a"}
SinglyLinkedList_void_ptr{&lt;pointer to 0x7fe5c0403b58&gt;, &lt;pointer to 0x7fe5c0403b68&gt;, &lt;pointer to 0x7fe5c0403b78&gt;}</code></pre><br/><p class="info note"><span>Using the custom formatter callback function to print out the content of a </span><code>SinglyLinkedList_void_ptr</code><span> storing user-defined </span><code>Object</code><span> type items
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Base type */</span><span>
</span><span class="code_keywords">typedef</span><span> </span><span class="code_keywords">struct</span><span>
{
    </span><span class="code_types">bool</span><span> hidden;
    </span><span class="code_types">float</span><span> value;
} Object;



</span><span class="code_comments">/* Formatter callback */</span><span>
</span><span class="code_keywords">static</span><span> </span><span class="code_types">bool</span><span>
</span><span class="code_functions">Object_repr</span><span>(</span><span class="code_keywords">const</span><span> Object </span><span class="code_operators">*</span><span>object,
            </span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>buffer,
            </span><span class="code_types">size_t</span><span> </span><span class="code_operators">*</span><span>buffer_size)
{
</span><span class="code_macros">    #define</span><span> </span><span class="code_functions">REPR</span><span>(value) </span><span class="code_strings">"Object{"</span><span> value </span><span class="code_strings">"}"</span><span>
</span><span class="code_macros">    #define</span><span> HIDDEN </span><span class="code_functions">REPR</span><span>(</span><span class="code_strings">"HIDDEN"</span><span>)
</span><span class="code_macros">    #define</span><span> PUBLIC </span><span class="code_functions">REPR</span><span>(</span><span class="code_strings">".f=%f"</span><span>)
    
    </span><span class="code_comments">/* Number of digits needed by the float value */</span><span>
    </span><span class="code_types">size_t</span><span> public_size </span><span class="code_operators">=</span><span> </span><span class="code_functions">snprintf</span><span>(</span><span class="code_constants">NULL</span><span>, </span><span class="code_numbers">0</span><span>, </span><span class="code_strings">"%f"</span><span>, object</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>value) </span><span class="code_operators">+</span><span> </span><span class="code_keywords">sizeof</span><span> PUBLIC;
    
    </span><span class="code_comments">/* Resize buffer if necessary */</span><span>
    </span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span>(</span><span class="code_operators">*</span><span>buffer_size </span><span class="code_operators">&gt;</span><span></span><span class="code_operators">=</span><span> public_size </span><span class="code_operators">&amp;</span><span></span><span class="code_operators">&amp;</span><span> </span><span class="code_operators">*</span><span>buffer_size </span><span class="code_operators">&gt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_keywords">sizeof</span><span> HIDDEN))
    {
        </span><span class="code_comments">/* If resize failed */</span><span>
        </span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span>(</span><span class="code_operators">*</span><span>buffer </span><span class="code_operators">=</span><span> </span><span class="code_functions">realloc</span><span>(</span><span class="code_operators">*</span><span>buffer, public_size)))
            </span><span class="code_keywords">return</span><span> </span><span class="code_constants">false</span><span>;
        </span><span class="code_operators">*</span><span>buffer_size </span><span class="code_operators">=</span><span> public_size;
    }
    
    </span><span class="code_comments">/* Format string representation*/</span><span>
    </span><span class="code_keywords">if</span><span> (object</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>hidden)
        </span><span class="code_functions">snprintf</span><span>(</span><span class="code_operators">*</span><span>buffer, </span><span class="code_operators">*</span><span>buffer_size, HIDDEN);
    </span><span class="code_keywords">else</span><span>
        </span><span class="code_functions">snprintf</span><span>(</span><span class="code_operators">*</span><span>buffer, </span><span class="code_operators">*</span><span>buffer_size, PUBLIC, object</span><span class="code_operators">-</span><span></span><span class="code_operators">&gt;</span><span>value);
    </span><span class="code_keywords">return</span><span> </span><span class="code_constants">true</span><span>;
}



</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
    </span><span class="code_types">bool</span><span> check;
    
    SinglyLinkedList_void_ptr </span><span class="code_operators">*</span><span>objects;
    check </span><span class="code_operators">=</span><span> </span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>objects, </span><span class="code_keywords">sizeof</span><span>(Object), </span><span class="code_numbers">2</span><span>, ((Object[]){{</span><span class="code_operators">.</span><span>hidden</span><span class="code_operators">=</span><span></span><span class="code_constants">true</span><span>,  </span><span class="code_operators">.</span><span>value</span><span class="code_operators">=</span><span></span><span class="code_numbers">42.f</span><span>},
                                                         {</span><span class="code_operators">.</span><span>hidden</span><span class="code_operators">=</span><span></span><span class="code_constants">false</span><span>, </span><span class="code_operators">.</span><span>value</span><span class="code_operators">=</span><span></span><span class="code_numbers">3.14f</span><span>}}));
    </span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span>check)
    {
        </span><span class="code_functions">fprintf</span><span>(</span><span class="code_constants">stderr</span><span>, </span><span class="code_strings">"Allocation failed\n"</span><span>);
        </span><span class="code_keywords">return</span><span> </span><span class="code_constants">EXIT_FAILURE</span><span>;
    }
    </span><span class="code_functions">print</span><span>(objects, Object_repr);
    
    </span><span class="code_functions">del</span><span>(objects);
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList{Object{HIDDEN}, Object{.f=3.140000}}</code></pre><br/></div><div class="entity" id="func_len"><p><span class="name">len</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>len</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList, and returns the number of items stored in the list (the length of the list).
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Number of items in the list</span></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get length of list:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list of unsigned longs */</span><span>
SinglyLinkedList_unsigned_long </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">unsigned</span><span> </span><span class="code_types">long</span><span>[]){</span><span class="code_numbers">75ul</span><span>, </span><span class="code_numbers">44ul</span><span>, </span><span class="code_numbers">79ul</span><span>, </span><span class="code_numbers">125ul</span><span>, </span><span class="code_numbers">68ul</span><span>}));

</span><span class="code_comments">/* Check length of list */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Number of items in list: %zu\n"</span><span>, </span><span class="code_functions">len</span><span>(linlist));

</span><span class="code_comments">/* Destroy list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Number of items in list: 5</code></pre><br/></div><div class="entity" id="func_clear"><p><span class="name">clear</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>clear</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific SinglyLinkedList and makes it empty. 
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get length of list:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create and fill list */</span><span>
SinglyLinkedList_signed_char </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">signed</span><span> </span><span class="code_types">char</span><span>[]){</span><span class="code_operators">-</span><span></span><span class="code_numbers">5</span><span>, </span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">5</span><span>}));

</span><span class="code_comments">/* Check length list */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Number of items in list: %zu\n"</span><span>, </span><span class="code_functions">len</span><span>(linlist));
</span><span class="code_functions">clear</span><span>(linlist);

</span><span class="code_comments">/* Check length list */</span><span>
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Number of items in list: %zu\n"</span><span>, </span><span class="code_functions">len</span><span>(linlist));

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Number of items in list: 3
Number of items in list: 0</code></pre><br/></div><div class="entity" id="func_iter"><p><span class="name">iter</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>iter</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList and returns an iterator object which can be iterated by the </span><a class="inline_link" href="#func_next"><span>next</span></a><span> function. For examples look at the examples of the </span><a class="inline_link" href="#func_next"><span>next</span></a><span> function.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>SinglyLinkedList_type_iterator *</span></code><span class="return_case">:</span><span>It returns an iterator object even if the list is empty. The </span><a class="inline_link" href="#func_next"><span>next</span></a><span> function can be called at least at once on the returned object.
</span></p><br/></div><div class="entity" id="func_next"><p><span class="name">next</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type_iterator *</span><span class="space_arg_type_name"> </span><span class="arg_name">iterator</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type **</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>next</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific iterator of a SinglyLinkedList and a pointer to a pointer of the given type and gets the next value from the iterator of the list created by the </span><a class="inline_link" href="#func_iter"><span>iter</span></a><span> function and redirect the pointer to the value in the list.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if iterator has more value</span></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">2nd argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Iterate through a list of </span><code>float</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list of floats */</span><span>
SinglyLinkedList_float </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">float</span><span>[]){</span><span class="code_numbers">1.341f</span><span>, </span><span class="code_numbers">9.019f</span><span>, </span><span class="code_numbers">33.907f</span><span>})))
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Allocation failed\n"</span><span>);

</span><span class="code_comments">/* Create iterator object */</span><span>
SinglyLinkedList_float_iterator </span><span class="code_operators">*</span><span>iter_linlist </span><span class="code_operators">=</span><span> </span><span class="code_functions">iter</span><span>(linlist);

</span><span class="code_comments">/* Iterate through the list and print its items */</span><span>
</span><span class="code_types">float</span><span> </span><span class="code_operators">*</span><span>item;
</span><span class="code_keywords">while</span><span>(</span><span class="code_functions">next</span><span>(iter_linlist, </span><span class="code_operators">&amp;</span><span>item))
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"%f\n"</span><span>, </span><span class="code_operators">*</span><span>item);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">1.341000
9.019000
33.907001</code></pre><br/><p class="info note"><span>Iterate through a list of </span><code>char*</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list of strings */</span><span>
SinglyLinkedList_char_ptr </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">char</span><span></span><span class="code_operators">*</span><span>[]){</span><span class="code_strings">"1 1/2 ounces vodka"</span><span>,
                                 </span><span class="code_strings">"  3/4 ounce Kahlua coffee liqueur"</span><span>,
                                 </span><span class="code_strings">"  3/4 ounce cream"</span><span>})))
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Allocation failed\n"</span><span>);

</span><span class="code_comments">/* Create iterator object */</span><span>
SinglyLinkedList_char_ptr_iterator </span><span class="code_operators">*</span><span>iter_linlist </span><span class="code_operators">=</span><span> </span><span class="code_functions">iter</span><span>(linlist);

</span><span class="code_comments">/* Iterate through the list and print its items */</span><span>
</span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span></span><span class="code_operators">*</span><span>item;
</span><span class="code_keywords">while</span><span>(</span><span class="code_functions">next</span><span>(iter_linlist, </span><span class="code_operators">&amp;</span><span>item))
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"%s\n"</span><span>, </span><span class="code_operators">*</span><span>item);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">1 1/2 ounces vodka
  3/4 ounce Kahlua coffee liqueur
  3/4 ounce cream</code></pre><br/></div><div class="entity" id="func_swap"><p><span class="name">swap</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index1</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index2</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">swap</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index1</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index2</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>swap</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList, an index to the first element of the first block, another index to the first element of the second block, and the number of elements in the blocks and swaps the two blocks inside the list. </span><code>swap</code><span> also has a variant, where the last argument can be dropped and it will be passed as the defualt </span><code>1</code><span>.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the swapping was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if there was nothing to swap (indices are the same, the list is empty, etc.) or the swap was successful
</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if list is a pointer to </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if one of the indices is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>The 1st index passed is greater than the number of items in the list.</span></p><br/><code class="exception_message">3rd argument is out of range</code><p class="exception_note"><span>The 2nd index passed is greater than the number of items in the list.</span></p><br/><code class="exception_message">blocks are overlapping</code><p class="exception_note"><span>It is more like a warning or note: the passed count argument is greater than the number of items between the two indices. The execution of the function will continue and the function will use the maximum available number of items to swap, so one can ignore this exception.
</span></p><br/><code class="exception_message">4th argument is out of range</code><p class="exception_note"><span>The count argument is greater than the number of items between the greater index and the end of the list. The execution of the function will continue and the function will use the maximum available number of items to swap, so one can ignore this exception.
</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Swap a single </span><code>unsigned integer</code><span> in list:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create, fill and print list */</span><span>
SinglyLinkedList_unsigned_int </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">unsigned</span><span>[]){</span><span class="code_numbers">3u</span><span>, </span><span class="code_numbers">9u</span><span>, </span><span class="code_numbers">6u</span><span>, </span><span class="code_numbers">12u</span><span>}));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Before swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Swap elements and print list again */</span><span>
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">swap</span><span>(linlist, </span><span class="code_numbers">1</span><span>, </span><span class="code_numbers">2</span><span>))
  </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Oups! Something went wrong during swapping.."</span><span>);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"\nAfter swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Destroy list and its content */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Before swap:
SinglyLinkedList_unsigned_int{3, 9, 6, 12}

After swap:
SinglyLinkedList_unsigned_int{3, 6, 9, 12}</code></pre><br/><p class="info note"><span>Swap blocks of </span><code>long</code><span>s in list:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create, fill and print list */</span><span>
SinglyLinkedList_long </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">6</span><span>, ((</span><span class="code_types">long</span><span>[]){</span><span class="code_numbers">13l</span><span>, </span><span class="code_numbers">21l</span><span>, </span><span class="code_numbers">5l</span><span>, </span><span class="code_numbers">8l</span><span>, </span><span class="code_numbers">2l</span><span>, </span><span class="code_numbers">3l</span><span>}));
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Before swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Swap elements and print list again */</span><span>
</span><span class="code_keywords">if</span><span> (</span><span class="code_operators">!</span><span></span><span class="code_functions">swap</span><span>(linlist, </span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">4</span><span>, </span><span class="code_numbers">2</span><span>))
  </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"Oh, snap.. Not again!"</span><span>);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"\nAfter swap:\n"</span><span>);
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Destroy list and its content */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">Before swap:
SinglyLinkedList_long{13, 21, 5, 8, 2, 3}

After swap:
SinglyLinkedList_long{2, 3, 5, 8, 13, 21}</code></pre><br/></div><div class="entity" id="func_reverse"><p><span class="name">reverse</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>reverse</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList and reverses the content of the list.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the reversing was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if list has been successfully reversed</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if list is a pointer to </span><code>NULL</code><span></span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Reversing an list of </span><code>size_t</code><span>s:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list */</span><span>
SinglyLinkedList_size_t </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">6</span><span>, ((</span><span class="code_types">size_t</span><span>[]){</span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">5</span><span>, </span><span class="code_numbers">10</span><span>, </span><span class="code_numbers">15</span><span>, </span><span class="code_numbers">20</span><span>, </span><span class="code_numbers">25</span><span>}));

</span><span class="code_comments">/* Reverse list */</span><span>
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_functions">reverse</span><span>(linlist);
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_size_t{0, 5, 10, 15, 20, 25}
SinglyLinkedList_size_t{25, 20, 15, 10, 5, 0}</code></pre><br/></div><div class="entity" id="func_append"><p><span class="name">append</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">append</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>append</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList and a pointer to a single item or the number of items and a pointer to the items and appends the item(s) at the end of the list.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the addition was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if item(s) was/were successfully appended to the list</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if list is a pointer to </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if internal reallocation failed</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">3rd argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">internal reallocation failed</code><p class="exception_note"><span>The function could not reallocate more space in the memory for the new item(s)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>First append two items, then a single one to an initially empty list of </span><code>char</code><span>s
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list */</span><span>
SinglyLinkedList_char </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist);

</span><span class="code_comments">/* Append to list */</span><span>
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_functions">append</span><span>(linlist, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">char</span><span>[]){</span><span class="code_strings">'u'</span><span>, </span><span class="code_strings">'v'</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_functions">append</span><span>(linlist, (</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">char</span><span>){</span><span class="code_strings">'w'</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_char{}
SinglyLinkedList_char{'u', 'v'}
SinglyLinkedList_char{'u', 'v', 'w'}</code></pre><br/><p class="info note"><span>Adding pointers to </span><code>NULL</code><span> to </span><code>SinglyLinkedList_void_ptr</code><span>:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Base values */</span><span>
</span><span class="code_types">int</span><span>   i, j, k;
</span><span class="code_types">float</span><span> l, m;

</span><span class="code_comments">/* Create a list from a pointer to NULL and pointers to int */</span><span>
SinglyLinkedList_void_ptr </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_keywords">sizeof</span><span>(</span><span class="code_types">void</span><span></span><span class="code_operators">*</span><span>), </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>[]){</span><span class="code_constants">NULL</span><span>, </span><span class="code_operators">&amp;</span><span>i, </span><span class="code_operators">&amp;</span><span>j, </span><span class="code_operators">&amp;</span><span>k}));

</span><span class="code_comments">/* Append a single pointer to NULL */</span><span>
</span><span class="code_functions">append</span><span>(linlist, (</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">void</span><span> </span><span class="code_operators">*</span><span>){</span><span class="code_constants">NULL</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Append two more pointers to floats */</span><span>
</span><span class="code_functions">append</span><span>(linlist, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">void</span><span></span><span class="code_operators">*</span><span>[]){</span><span class="code_operators">&amp;</span><span>l, </span><span class="code_operators">&amp;</span><span>m}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_void_ptr{&lt;pointer to NULL&gt;, &lt;pointer to 0x7f8c30d00048&gt;, &lt;pointer to 0x7f8c30d00058&gt;, &lt;pointer to 0x7f8c30d00068&gt;, &lt;pointer to NULL&gt;}
SinglyLinkedList_void_ptr{&lt;pointer to NULL&gt;, &lt;pointer to 0x7f8c30d00048&gt;, &lt;pointer to 0x7f8c30d00058&gt;, &lt;pointer to 0x7f8c30d00068&gt;, &lt;pointer to NULL&gt;, &lt;pointer to 0x7f8c30d00108&gt;, &lt;pointer to 0x7f8c30d00118&gt;}</code></pre><br/></div><div class="entity" id="func_push"><p><span class="name">push</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">push</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>push</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific SinglyLinkedList, an index, a pointer to the source and
optionally the number of items. It inserts item(s) before the given
index and shifts the data already there.
</span><br/><span></span><br/><span>
</span><b><i><span>Note:</span></i></b><span> Why </span><code>push</code><span> and </span><code>pull</code><span> instead of the more intuitive
</span><code>insert</code><span> and </span><code>remove</code><span>? The main reason, is because the standard
library already uses the function name </span><code>remove</code><span> in </span><code>stdio</code><span>. Of course
dispatching between the standard and the cutils calls would be easy. (One
has to add a </span><code>const char *</code><span> to the </span><code>_Generic</code><span> assocation list of this
function.) However using an alternative version, </span><code>pull</code><span>, is still a nicer
solution. Besides, it is even shorter! And to keep the naming consistent,
if </span><code>remove</code><span>'s pair is </span><code>insert</code><span>, then </span><code>pull</code><span>'s pair is </span><code>push</code><span>!
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the insertion was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if item(s) was/were successfully inserted to the list</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if list is a pointer to </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if internal reallocation failed</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">4th argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">internal reallocation failed</code><p class="exception_note"><span>The function could not reallocate more space in the memory for the new item(s)</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Insert a single item at the second place of the list, then insert two more at the beginning of the list
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list */</span><span>
SinglyLinkedList_short </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">short</span><span>[]){(</span><span class="code_types">short</span><span>)</span><span class="code_numbers">3</span><span>, (</span><span class="code_types">short</span><span>)</span><span class="code_numbers">5</span><span>, (</span><span class="code_types">short</span><span>)</span><span class="code_numbers">6</span><span>, (</span><span class="code_types">short</span><span>)</span><span class="code_numbers">7</span><span>}));

</span><span class="code_comments">/* Insert items into list */</span><span>
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_functions">push</span><span>(linlist, </span><span class="code_numbers">1</span><span>, (</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">short</span><span>){</span><span class="code_numbers">4</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_functions">push</span><span>(linlist, </span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">2</span><span>, ((</span><span class="code_types">short</span><span>[]){(</span><span class="code_types">short</span><span>)</span><span class="code_numbers">1</span><span>, (</span><span class="code_types">short</span><span>)</span><span class="code_numbers">2</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_short{3, 5, 6, 7}
SinglyLinkedList_short{3, 4, 5, 6, 7}
SinglyLinkedList_short{1, 2, 3, 4, 5, 6, 7}</code></pre><br/></div><div class="entity" id="func_pull"><p><span class="name">pull</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">pull</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>pull</code><span> is a type-generic function-like macro, which takes a pointer
to a type-specific SinglyLinkedList, an index, and optionally the number
items, and it will remove it/them from the list.
</span><br/><span></span><br/><span>
</span><b><i><span>Note:</span></i></b><span> Why </span><code>push</code><span> and </span><code>pull</code><span> instead of the more intuitive
</span><code>insert</code><span> and </span><code>remove</code><span>? The main reason, is because the standard
library already uses the function name </span><code>remove</code><span> in </span><code>stdio</code><span>. Of course
dispatching between the standard and the cutils calls would be easy. (One
has to add a </span><code>const char *</code><span> to the </span><code>_Generic</code><span> assocation list of this
function.) However using an alternative version, </span><code>pull</code><span>, is still a nicer
solution. Besides, it is even shorter! And to keep the naming consistent,
if </span><code>remove</code><span>'s pair is </span><code>insert</code><span>, then </span><code>pull</code><span>'s pair is </span><code>push</code><span>!
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Indicates the number of items has been successfully removed.</span><br/></p><table class="return_values"><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if index out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Remove the last item, then the second and third ones from the list
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list */</span><span>
SinglyLinkedList_bool </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">bool</span><span>[]){</span><span class="code_constants">true</span><span>, </span><span class="code_constants">false</span><span>, </span><span class="code_constants">false</span><span>, </span><span class="code_constants">true</span><span>, </span><span class="code_constants">false</span><span>}));

</span><span class="code_comments">/* Remove items from list */</span><span>
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_functions">pull</span><span>(linlist, </span><span class="code_functions">len</span><span>(linlist) </span><span class="code_operators">-</span><span> </span><span class="code_numbers">1</span><span>);
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_functions">pull</span><span>(linlist, </span><span class="code_numbers">1</span><span>, </span><span class="code_numbers">2</span><span>);
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_bool{true, false, false, true, false}
SinglyLinkedList_bool{true, false, false, true}
SinglyLinkedList_bool{true, true}</code></pre><br/></div><div class="entity" id="func_pop"><p><span class="name">pop</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">destination</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">pop</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">destination</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>pop</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList, an index, a pointer to type of destination and optionally the number of items to pop. It will remove the items specified by the index from the list and copy it to the destination.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Indicates the number of items has been successfully popped.</span><br/></p><table class="return_values"><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer to list is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer destination is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if list is empty</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>index</code><span> is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">4th argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Pop out a single item, and then another two from the list
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list */</span><span>
SinglyLinkedList_double </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">double</span><span>[]){</span><span class="code_numbers">23.974624</span><span>, </span><span class="code_numbers">10.</span><span>, </span><span class="code_numbers">86.666667</span><span>, </span><span class="code_numbers">3.14</span><span>, </span><span class="code_numbers">.56</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Create destination storages */</span><span>
</span><span class="code_macros">#define</span><span> NUMS </span><span class="code_numbers">3</span><span>
</span><span class="code_types">double</span><span> number;
</span><span class="code_types">double</span><span> numbers[NUMS];

</span><span class="code_comments">/* Pop a single item from list to destination */</span><span>
</span><span class="code_functions">pop</span><span>(linlist, </span><span class="code_numbers">0</span><span>, </span><span class="code_operators">&amp;</span><span>number);
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"popped: %lf\n"</span><span>, number);

</span><span class="code_comments">/* Pop a multiple items from list to destination */</span><span>
</span><span class="code_functions">pop</span><span>(linlist, </span><span class="code_numbers">1</span><span>, NUMS, numbers);
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>NUMS; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"popped [%zu] %lf\n"</span><span>, i, numbers[i]);

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_double{23.974624, 10.000000, 86.666667, 3.140000, 0.560000}
SinglyLinkedList_double{10.000000, 10.000000, 86.666667, 3.140000}
popped: 23.974624
SinglyLinkedList_double{10.000000}
popped [0] 10.000000
popped [1] 86.666667
popped [2] 3.140000</code></pre><br/></div><div class="entity" id="func_sub"><p><span class="name">sub</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">destination</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">sub</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">destination</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>sub</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList, an index, a pointer to type of destination and optionally the number of items to sub-copy. It will copy the items specified by the index from the list to the destination.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>size_t</span></code><span class="return_case">:</span><span>Indicates the number of items has been successfully copied.</span><br/></p><table class="return_values"><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer to list is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer destination is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if list is empty</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>index</code><span> is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">4th argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Copy a single item, and then five other items from the list
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list */</span><span>
SinglyLinkedList_long_long </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">6</span><span>, ((</span><span class="code_types">long</span><span> </span><span class="code_types">long</span><span>[]){</span><span class="code_numbers">11ll</span><span>, </span><span class="code_numbers">22ll</span><span>, </span><span class="code_numbers">33ll</span><span>, </span><span class="code_numbers">44ll</span><span>, </span><span class="code_numbers">55ll</span><span>, </span><span class="code_numbers">66ll</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Create destination storages */</span><span>
</span><span class="code_macros">#define</span><span> NUMS </span><span class="code_numbers">5</span><span>
</span><span class="code_types">long</span><span> </span><span class="code_types">long</span><span> number;
</span><span class="code_types">long</span><span> </span><span class="code_types">long</span><span> numbers[NUMS];

</span><span class="code_comments">/* Pop a single item from list to destination */</span><span>
</span><span class="code_functions">sub</span><span>(linlist, </span><span class="code_numbers">2</span><span>, </span><span class="code_operators">&amp;</span><span>number);
</span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"copied: %lld\n"</span><span>, number);

</span><span class="code_comments">/* Pop a multiple item from list to destination */</span><span>
</span><span class="code_functions">sub</span><span>(linlist, </span><span class="code_numbers">1</span><span>, NUMS, numbers);
</span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>NUMS; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"copied: [%zu] %lld\n"</span><span>, i, numbers[i]);
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_long_long{11, 22, 33, 44, 55, 66}
copied: 33
copied: [0] 22
copied: [1] 33
copied: [2] 44
copied: [3] 55
copied: [4] 66
SinglyLinkedList_long_long{11, 22, 33, 44, 55, 66}</code></pre><br/></div><div class="entity" id="func_truncate"><p><span class="name">truncate</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>truncate</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList and an index. It removes all items starts from the index.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Truncating from the last element, and then from the second element
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Variables */</span><span>
</span><span class="code_types">int</span><span> a, b, c, d, e;

</span><span class="code_comments">/* Create list */</span><span>
SinglyLinkedList_ptrdiff_t </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">4</span><span>, ((</span><span class="code_types">ptrdiff_t</span><span>[]){</span><span class="code_operators">&amp;</span><span>a </span><span class="code_operators">-</span><span> </span><span class="code_operators">&amp;</span><span>d, </span><span class="code_operators">&amp;</span><span>e </span><span class="code_operators">-</span><span> </span><span class="code_operators">&amp;</span><span>b, </span><span class="code_operators">&amp;</span><span>b </span><span class="code_operators">-</span><span> </span><span class="code_operators">&amp;</span><span>c, </span><span class="code_operators">&amp;</span><span>d </span><span class="code_operators">-</span><span> </span><span class="code_operators">&amp;</span><span>b}));

</span><span class="code_comments">/* Truncate list from the item befire the last one */</span><span>
</span><span class="code_functions">print</span><span>(linlist);
</span><span class="code_functions">truncate</span><span>(linlist, </span><span class="code_functions">len</span><span>(linlist) </span><span class="code_operators">-</span><span> </span><span class="code_numbers">2</span><span>);
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Truncate list from the first item */</span><span>
</span><span class="code_functions">truncate</span><span>(linlist, </span><span class="code_numbers">1</span><span>);
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_ptrdiff_t{3, -3, 1, -2}
SinglyLinkedList_ptrdiff_t{3, -3}
SinglyLinkedList_ptrdiff_t{3}</code></pre><br/></div><div class="entity" id="func_set"><p><span class="name">set</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">item</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span><br/><span class="name">set</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">item_count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">type *</span><span class="space_arg_type_name"> </span><span class="arg_name">items</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>set</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList, and index, a pointer to type as source and optionally the number of items. It sets the item/items at/starts from the given index in list.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>bool</span></code><span class="return_case">:</span><span>Indicates if the settings was successful or not.</span><br/></p><table class="return_values"><tr><td><code class="return_case">true</code></td><td><span class="return_case">:</span></td><td><span>if all items were set</span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if pointer to list is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>item</code><span>/</span><code>items</code><span> is pointing to </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">false</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>index</code><span> is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">4th argument is `NULL`</code><p class="exception_note"><span>if the </span><code>item</code><span>/</span><code>items</code><span> pointer pointing to </span><code>NULL</code><span></span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Set a single item, and then three other items in the list
:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list */</span><span>
SinglyLinkedList_int </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">7</span><span>, ((</span><span class="code_types">int</span><span>[]){</span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">7</span><span>, </span><span class="code_numbers">2</span><span>, </span><span class="code_numbers">0</span><span>, </span><span class="code_numbers">2</span><span>, </span><span class="code_numbers">1</span><span>, </span><span class="code_numbers">6</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Set second item in list */</span><span>
</span><span class="code_functions">set</span><span>(linlist, </span><span class="code_numbers">1</span><span>, (</span><span class="code_operators">&amp;</span><span>(</span><span class="code_types">int</span><span>){</span><span class="code_numbers">1</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Set three items starting from the third item in list */</span><span>
</span><span class="code_functions">set</span><span>(linlist, </span><span class="code_numbers">3</span><span>, </span><span class="code_numbers">3</span><span>, ((</span><span class="code_types">int</span><span>[]){</span><span class="code_numbers">3</span><span>, </span><span class="code_numbers">4</span><span>, </span><span class="code_numbers">5</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_int{0, 7, 2, 0, 2, 1, 6}
SinglyLinkedList_int{0, 1, 2, 0, 2, 1, 6}
SinglyLinkedList_int{0, 1, 2, 3, 4, 5, 6}</code></pre><br/></div><div class="entity" id="func_get"><p><span class="name">get</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>get</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList and an index. It returns a properly casted to type item, except for </span><code>SinglyLinkedList_void_ptr</code><span>, where it returns a pointer to the pointer stored in the list.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>type *</span></code><span class="return_case">:</span><span>returns a properly casted to type item</span><br/></p><table class="return_values"><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if pointer to arrat is </span><code>NULL</code><span></span></td></tr><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if list is empty</span></td></tr><tr><td><code class="return_case">NULL</code></td><td><span class="return_case">:</span></td><td><span>if </span><code>index</code><span> is out of range</span></td></tr></table><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is out of range</span></p><br/><p class="info label">Examples:</p><p class="info note"><span>Get each </span><code>float</code><span> and the next one from the list and add them:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_comments">/* Create list */</span><span>
</span><span class="code_macros">#define</span><span> SIZE </span><span class="code_numbers">4</span><span>
SinglyLinkedList_float </span><span class="code_operators">*</span><span>linlist;
</span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, SIZE, ((</span><span class="code_types">float</span><span>[]){</span><span class="code_numbers">4.78</span><span>, </span><span class="code_numbers">99.</span><span>, </span><span class="code_numbers">13.62</span><span>, </span><span class="code_numbers">.123</span><span>}));
</span><span class="code_functions">print</span><span>(linlist);

</span><span class="code_comments">/* Add together all items and their neighbours from the list */</span><span>
</span><span class="code_types">float</span><span> a, b;
</span><span class="code_keywords">for</span><span> (</span><span class="code_types">size_t</span><span> i</span><span class="code_operators">=</span><span></span><span class="code_numbers">0</span><span>; i</span><span class="code_operators">&lt;</span><span>SIZE </span><span class="code_operators">-</span><span> </span><span class="code_numbers">1</span><span>; i</span><span class="code_operators">+</span><span></span><span class="code_operators">+</span><span>)
{
    a </span><span class="code_operators">=</span><span> </span><span class="code_functions">get</span><span>(linlist, i);
    b </span><span class="code_operators">=</span><span> </span><span class="code_functions">get</span><span>(linlist, i </span><span class="code_operators">+</span><span> </span><span class="code_numbers">1</span><span>);
    </span><span class="code_functions">printf</span><span>(</span><span class="code_strings">"%.2f + %.2f = %.2f\n"</span><span>, a, b, a </span><span class="code_operators">+</span><span> b);
}

</span><span class="code_comments">/* Delete list */</span><span>
</span><span class="code_functions">del</span><span>(linlist);
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_float{4.780000, 99.000000, 13.620000, 0.123000}
4.78 + 99.00 = 103.78
99.00 + 13.62 = 112.62
13.62 + 0.12 = 13.74</code></pre><br/></div><div class="entity" id="func_map"><p><span class="name">map</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">void (*</span><span class="space_arg_type_name"> </span><span class="arg_name">function</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(size_t, type*)</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span><br/><span class="name">map</span><span class="space_name_arg_paren"> </span><span class="arg_paren">(</span><span class="space_arg_comma_type"> </span><span class="arg_type">SinglyLinkedList_type *</span><span class="space_arg_type_name"> </span><span class="arg_name">linked_list</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">index</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">size_t</span><span class="space_arg_type_name"> </span><span class="arg_name">count</span><span class="space_arg_name_paren"> </span><span class="arg_comma">,</span><span class="space_arg_comma_type"> </span><span class="arg_type">void (*</span><span class="space_arg_type_name"> </span><span class="arg_name">function</span><span class="space_arg_name_paren"> </span><span class="arg_type">)(size_t, type*)</span><span class="space_arg_type_name"> </span><span class="arg_paren">)</span></p><br/><p class="info"><span></span><code>map</code><span> is a type-generic function-like macro, which takes a pointer to a type-specific SinglyLinkedList and a function. It will call the function on every item in the list. It can also take two more optional arguments: an </span><code>index</code><span> which is where the mapping starts from, and a </span><code>count</code><span> which indicates how many items the function will be called on.
</span></p><br/><p class="info return"><span class="label">Return: </span><code class="return_case"><span>void</span></code></p><br/><p class="info label">Exceptions:</p><code class="exception_message">object pointer is pointing to NULL</code><p class="exception_note"><span>Function cannot operate on </span><code>NULL</code><span> pointer. Note: this exception only occurs when the passed pointer to object is pointing to </span><code>NULL</code><span>, otherwise if the pointer is pointing to some memory garbage it will be considered as a perfectly legal argument. (However in that case probably a </span><code>SEGMENTATION FAULT</code><span> error will be generated.)</span></p><br/><code class="exception_message">object is empty</code><p class="exception_note"><span>This exceptions is more like a warning or a notification rather than an actual error. The passed object is empty, which may or may not be the situation one wanted. The return value (</span><i><span>error signal</span></i><span>) if there is any, will also indicate success, therefore this exception can be ignored.</span></p><br/><code class="exception_message">2nd argument is out of range</code><p class="exception_note"><span>if the </span><code>index</code><span> argument is greater than the length of the list</span></p><br/><code class="exception_message">4th argument is out of range</code><p class="exception_note"><span>if the </span><code>function</code><span> argument is pointing to </span><code>NULL</code><span></span></p><br/><p class="info label">Examples:</p><p class="info note"><span></span><i><span>Rotate</span></i><span> all characters by 13 in the list:</span></p><br/><pre class="info"><code class="snippet"><span></span><span class="code_keywords">static</span><span> </span><span class="code_types">void</span><span>
</span><span class="code_functions">rot13</span><span>(</span><span class="code_types">size_t</span><span> index, </span><span class="code_types">char</span><span> </span><span class="code_operators">*</span><span>letter)
{
    </span><span class="code_types">int</span><span> upper </span><span class="code_operators">=</span><span> </span><span class="code_functions">toupper</span><span>(</span><span class="code_operators">*</span><span>letter);
    </span><span class="code_keywords">if</span><span> (upper </span><span class="code_operators">&gt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_strings">'A'</span><span> </span><span class="code_operators">&amp;</span><span></span><span class="code_operators">&amp;</span><span> upper </span><span class="code_operators">&lt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_strings">'M'</span><span>)
        </span><span class="code_operators">*</span><span>letter </span><span class="code_operators">+</span><span></span><span class="code_operators">=</span><span> </span><span class="code_numbers">13</span><span>;
    </span><span class="code_keywords">else</span><span> </span><span class="code_keywords">if</span><span> (upper </span><span class="code_operators">&gt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_strings">'N'</span><span> </span><span class="code_operators">&amp;</span><span></span><span class="code_operators">&amp;</span><span> upper </span><span class="code_operators">&lt;</span><span></span><span class="code_operators">=</span><span> </span><span class="code_strings">'Z'</span><span>)
        </span><span class="code_operators">*</span><span>letter </span><span class="code_operators">-</span><span></span><span class="code_operators">=</span><span> </span><span class="code_numbers">13</span><span>;
}



</span><span class="code_types">int</span><span> </span><span class="code_functions">main</span><span>(</span><span class="code_types">void</span><span>)
{
    SinglyLinkedList_char </span><span class="code_operators">*</span><span>linlist;
    </span><span class="code_functions">new</span><span>(</span><span class="code_operators">&amp;</span><span>linlist, </span><span class="code_numbers">5</span><span>, ((</span><span class="code_types">char</span><span>[]){</span><span class="code_strings">'a'</span><span>, </span><span class="code_strings">'b'</span><span>, </span><span class="code_strings">'c'</span><span>, </span><span class="code_strings">'d'</span><span>, </span><span class="code_strings">'e'</span><span>}));
    </span><span class="code_functions">print</span><span>(linlist);
    
    </span><span class="code_functions">map</span><span>(linlist, rot13);
    </span><span class="code_functions">print</span><span>(linlist);
    
    </span><span class="code_keywords">return</span><span> </span><span class="code_numbers">0</span><span>;
}
</span></code></pre><br/><p class="info note"><span>OUTPUT:</span></p><br/><pre class="info"><code class="snippet">SinglyLinkedList_char{'a', 'b', 'c', 'd', 'e'}
SinglyLinkedList_char{'n', 'o', 'p', 'q', 'r'}</code></pre><br/></div></div></div></div></body></html>